<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interpolation of PDE solutions ¬∑ SparseGridsKit.jl</title><meta name="title" content="Interpolation of PDE solutions ¬∑ SparseGridsKit.jl"/><meta property="og:title" content="Interpolation of PDE solutions ¬∑ SparseGridsKit.jl"/><meta property="twitter:title" content="Interpolation of PDE solutions ¬∑ SparseGridsKit.jl"/><meta name="description" content="Documentation for SparseGridsKit.jl."/><meta property="og:description" content="Documentation for SparseGridsKit.jl."/><meta property="twitter:description" content="Documentation for SparseGridsKit.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="SparseGridsKit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SparseGridsKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">SparseGridsKit.jl</a></li><li><span class="tocitem">SparseGridsKit.jl by Examples</span><ul><li><a class="tocitem" href="../knots/">Knots</a></li><li><a class="tocitem" href="../misets/">Multi-Index Sets</a></li><li><a class="tocitem" href="../sparsegrids/">Sparse Grids</a></li><li><a class="tocitem" href="../sparsegridinterpolation/">Sparse Grid Interpolation</a></li><li><a class="tocitem" href="../sparsegridintegration/">Sparse Grid Integration</a></li><li><a class="tocitem" href="../adaptivesparsegrids/">Adaptive Sparse Grids</a></li><li><a class="tocitem" href="../spectralsparsegrids/">Spectral Sparse Grids</a></li><li><a class="tocitem" href="../differentiation/">Approximation Differentiation</a></li><li><a class="tocitem" href="../multifidelity/">Multi-Fidelity Sparse Grid Approximation</a></li></ul></li><li><a class="tocitem" href="../plots/">Plotting</a></li><li><span class="tocitem">Extensions</span><ul><li class="is-active"><a class="tocitem" href>Interpolation of PDE solutions</a><ul class="internal"><li><a class="tocitem" href="#Example:-ApproxFun.jl"><span>Example: ApproxFun.jl</span></a></li></ul></li><li><a class="tocitem" href="../umbridge/">UM-Bridge</a></li></ul></li><li><a class="tocitem" href="../reference/">SparseGridsKit.jl Public API Reference</a></li><li><a class="tocitem" href="../bib/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Extensions</a></li><li class="is-active"><a href>Interpolation of PDE solutions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interpolation of PDE solutions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/benmkent/SparseGridsKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/benmkent/SparseGridsKit.jl/blob/main/docs/src/functioninterpolation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Sparse-Grids-for-More-General-Objects"><a class="docs-heading-anchor" href="#Sparse-Grids-for-More-General-Objects">Sparse Grids for More General Objects</a><a id="Sparse-Grids-for-More-General-Objects-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-Grids-for-More-General-Objects" title="Permalink"></a></h1><p>More general objects can be interpolated and integrated via <code>SparseGridsKit.jl</code>. The SparseGridsKit supports objects for which addition is defined. For example, we can could consider <a href="https://github.com/JuliaApproximation/ApproxFun.jl">ApproxFun</a> objects or even Python objects provided they support addition.</p><h2 id="Example:-ApproxFun.jl"><a class="docs-heading-anchor" href="#Example:-ApproxFun.jl">Example: ApproxFun.jl</a><a id="Example:-ApproxFun.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-ApproxFun.jl" title="Permalink"></a></h2><h3 id="One-Dimensional-Functions"><a class="docs-heading-anchor" href="#One-Dimensional-Functions">One Dimensional Functions</a><a id="One-Dimensional-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#One-Dimensional-Functions" title="Permalink"></a></h3><p>We can consider interpolation of <code>Fun</code> objects. First a parametric <code>Fun</code> object can be evaluated at sparse grid points.</p><pre><code class="language-julia hljs">using SparseGridsKit, ApproxFun, Plots, LaTeXStrings
n, k = 1, 1
mi_set = create_smolyak_miset(n, k)
sg = create_sparsegrid(mi_set)
f = y-&gt; Fun(Taylor(),[y,2,3])
f_on_grid = [f(x[1]) for x in get_grid_points(sg)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{ApproxFunBase.Fun{ApproxFunFourier.Taylor{ApproxFunFourier.Circle{Float64, Float64, ComplexF64}, ComplexF64}, Float64, Vector{Float64}}}:
 Fun(Taylor(üïí), [1.0, 2.0, 3.0])
 Fun(Taylor(üïí), [0.0, 2.0, 3.0])
 Fun(Taylor(üïí), [-1.0, 2.0, 3.0])</code></pre><p>The <code>Fun</code> objects can then be interpolated using the <code>interpolate_on_sparsegrid</code> function. The interpolated <code>Fun</code> objects are plotted below.</p><pre><code class="language-julia hljs">target_points = [[x] for x in -1.0:0.2:1.0]
interpolation_result = interpolate_on_sparsegrid(sg, f_on_grid, target_points)
plot(interpolation_result,
    xlims = (-2,2),
)</code></pre><img src="65a781db.svg" alt="Example block output"/><p>A challenge for some non-vector objects is intermediate scalar multiplications introduces additional allocations.</p><pre><code class="language-julia hljs">@time interpolate_on_sparsegrid(sg, f_on_grid, target_points)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">11-element Vector{ApproxFunBase.Fun{ApproxFunFourier.Taylor{ApproxFunFourier.Circle{Float64, Float64, ComplexF64}, ComplexF64}, Float64, Vector{Float64}}}:
 Fun(Taylor(üïí), [-1.0, 2.0, 3.0])
 Fun(Taylor(üïí), [-0.8, 2.0, 3.0])
 Fun(Taylor(üïí), [-0.6, 2.0, 3.0])
 Fun(Taylor(üïí), [-0.4, 2.0, 3.0])
 Fun(Taylor(üïí), [-0.2, 2.0, 3.0])
 Fun(Taylor(üïí), [0.0, 2.0, 3.0])
 Fun(Taylor(üïí), [0.2, 2.0, 3.0])
 Fun(Taylor(üïí), [0.4, 2.0, 3.0])
 Fun(Taylor(üïí), [0.6, 2.0, 3.0])
 Fun(Taylor(üïí), [0.8, 2.0, 3.0])
 Fun(Taylor(üïí), [1.0, 2.0, 3.0])</code></pre><p>Integration is also possible using the sparse grid formulation.</p><pre><code class="language-julia hljs">expectedvalue = integrate_on_sparsegrid(sg,f_on_grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Fun(Taylor(üïí), [0.0, 2.0, 3.0])</code></pre><h3 id="Two-dimensional-Elliptic-PDE"><a class="docs-heading-anchor" href="#Two-dimensional-Elliptic-PDE">Two dimensional Elliptic PDE</a><a id="Two-dimensional-Elliptic-PDE-1"></a><a class="docs-heading-anchor-permalink" href="#Two-dimensional-Elliptic-PDE" title="Permalink"></a></h3><p>The <code>ApproxFun</code> package offers a fast way to solve a model elliptic PDE. Given that the <code>Fun</code> objects can be used naturally within the <code>SparseGridsKit.jl</code>, we can consider computing an approximation to the solution of a parameteric elliptic PDE.</p><p>This is set up on a two dimensional spatial domain <span>$D=[-1,1]^2$</span>.</p><pre><code class="language-julia hljs">d = ChebyshevInterval()^2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(-1.0 .. 1.0 (Chebyshev)) √ó (-1.0 .. 1.0 (Chebyshev))</code></pre><p>A parametric forcing function is defined with a parameter domain <span>$\Gamma=[-1,1]^2$</span>.</p><pre><code class="language-julia hljs">x,y = Fun(d)
# Forcing is parametric
f = z -&gt; ProductFun((x,y)-&gt;exp.(-(1.01+z[1])*(x+0.3)^2-2(y-z[2])^2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">#7 (generic function with 1 method)</code></pre><p>The forced elliptic PDE</p><p class="math-container">\[-\nabla u(x,z) = f(x,z) \text{ for all } x \in D, u(x,z) = 0 \text{ for all } x \in \partial D\]</p><p>is easily solved pointwise for any parameter <span>$z \in \Gamma$</span>.</p><pre><code class="language-julia hljs">A = [Dirichlet(d); -Laplacian()]
# Sln is parametric
u = z -&gt; ProductFun(\(A, [zeros(‚àÇ(d)); f(z)]; tolerance=1E-6),d)

z = [0, 0]
uz = u(z)
plot(uz)
plot!(xlabel=L&quot;x_1&quot;,
        ylabel=L&quot;x_2&quot;,
        zlabel=L&quot;u(x,z)&quot;)</code></pre><img src="d602aee2.svg" alt="Example block output"/><p>A sparse grid approximation can be constructed. The pointwise solutions on the sparse grid can be interpolated to give an approximation at any point in the domain. The animation below illustrates the changing sparse grid approximation and the approximation error for parameters on the circle <span>$\Vert x \Vert_2 = 1$</span>.</p><pre><code class="language-julia hljs">n, k = 2,2
mi_set = create_smolyak_miset(n, k)
sg = create_sparsegrid(mi_set)
f_on_grid = [u(z) for z in get_grid_points(sg)]

nsteps = 100
points = get_grid_points(sg)
x = [p[1] for p in points]
y = [p[2] for p in points]
@gif for i in range(0, stop = 2œÄ, length = nsteps)
        z = [cos(i),sin(i)]
        interpolation_result = interpolate_on_sparsegrid(sg, f_on_grid, [z])

        p1 = plot(interpolation_result[1])
        plot!(zlims!(0,0.3),title=&quot;SG Approximation&quot;)
        plot!(xlabel=L&quot;x_1&quot;,
        ylabel=L&quot;x_2&quot;,
        zlabel=L&quot;u(x,z)&quot;)

        p2 = plot(interpolation_result[1]-u(z))
        plot!(zlims!(-3e-2,3e-2),title=&quot;Interpolation Error&quot;)
        plot!(xlabel=L&quot;x_1&quot;,
        ylabel=L&quot;x_2&quot;,
        zlabel=L&quot;e(x,z)&quot;)

        p3 = scatter(x,y,label=&quot;grid&quot;)
        scatter!(p3, [z[1]],[z[2]],label=&quot;z&quot;)
        plot(p1, p2, p3, layout=[2,2])
        plot!(xlabel=L&quot;y_1&quot;,
        ylabel=L&quot;y_2&quot;)
end</code></pre><img src="f39f22b0.gif" alt="Example block output"/><p>The sparse grid has been constructed using Clenshaw‚ÄìCurtis points. The quadrature rules can be applied assuming an underlying weight function <span>$\rho(y)=0.5^2$</span>. If this is interpreted as a probabiliy then integration gives the expected value of the PDE solution.</p><pre><code class="language-julia hljs">expectedvalue = ProductFun(integrate_on_sparsegrid(sg,f_on_grid),d)
plot(expectedvalue)
plot!(title=&quot;Approximation of Expected Value&quot;,
        xlabel=L&quot;x_1&quot;,
        ylabel=L&quot;x_2&quot;,
        zlabel=L&quot;\mathbb{E}[u(x,\cdot)]&quot;)</code></pre><img src="cd147b89.svg" alt="Example block output"/><p>Similarly an approximation of the variance can be computed and interpolated.</p><pre><code class="language-julia hljs">square = PF -&gt; ProductFun(PF*PF,d)
variance = ProductFun(integrate_on_sparsegrid(sg,[square(f_on_grid[i]-expectedvalue) for i in eachindex(f_on_grid)]),d)
plot(variance)
plot!(title=&quot;Approximation of Variance&quot;,
        xlabel=L&quot;x_1&quot;,
        ylabel=L&quot;x_2&quot;,
        zlabel=L&quot;Var[u(x,\cdot)]&quot;)</code></pre><img src="4b00b455.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../plots/">¬´ Plotting</a><a class="docs-footer-nextpage" href="../umbridge/">UM-Bridge ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 11 August 2025 07:00">Monday 11 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
