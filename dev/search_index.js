var documenterSearchIndex = {"docs":
[{"location":"spectralsparsegrids/#Spectral-Sparse-Grids","page":"Spectral Sparse Grids","title":"Spectral Sparse Grids","text":"","category":"section"},{"location":"spectralsparsegrids/","page":"Spectral Sparse Grids","title":"Spectral Sparse Grids","text":"The sparse grid approximations are polynomial approximations, with a basis of Lagrange interpolation polynomials. The approximation can be written in any suitable polynomial basis, for example we could use the Chebyshev polynomials.","category":"page"},{"location":"spectralsparsegrids/","page":"Spectral Sparse Grids","title":"Spectral Sparse Grids","text":"The change of basis is implemented exploiting the ApproxFun.jl package. The underlying interpolation polynomials used in SparseGridsKit.jl are constructed using Funs. To change basis we use an ApproxFun.jl expansion into coefficients and form a tensor product. To promote sparsity this is done using a truncated Kronecker product. The polynomial coefficients are assembled with corresponding polynomial degrees and spaces in a callable SpectralSparseGridApproximation.","category":"page"},{"location":"spectralsparsegrids/#Examples","page":"Spectral Sparse Grids","title":"Examples","text":"","category":"section"},{"location":"spectralsparsegrids/","page":"Spectral Sparse Grids","title":"Spectral Sparse Grids","text":"An adaptive sparse grid approximation for a Genz test function is created. ","category":"page"},{"location":"spectralsparsegrids/","page":"Spectral Sparse Grids","title":"Spectral Sparse Grids","text":"using SparseGridsKit\nn = 8\nC = 1.0\nW = 0.0\nT = \"exponentialdecay\"\nN = \"gaussianpeak\"\nf = genz(n::Int, C::Float64, W::Float64, T::String, N::String)\n# Approximate\n(sg, f_on_Z) = adaptive_sparsegrid(f, n)\nf_sg = SparseGridApproximation(sg,f_on_Z)","category":"page"},{"location":"spectralsparsegrids/","page":"Spectral Sparse Grids","title":"Spectral Sparse Grids","text":"The approximation f_sg is a representation formed as a linear combination of Lagrange interpolation polynomials. This is converted to a spectral representation using convert_to_spectral_approximation.","category":"page"},{"location":"spectralsparsegrids/","page":"Spectral Sparse Grids","title":"Spectral Sparse Grids","text":"f_spectral = convert_to_spectral_approximation(sg, f_on_Z)","category":"page"},{"location":"spectralsparsegrids/","page":"Spectral Sparse Grids","title":"Spectral Sparse Grids","text":"This still has an n dimensional domain.","category":"page"},{"location":"spectralsparsegrids/","page":"Spectral Sparse Grids","title":"Spectral Sparse Grids","text":"f_spectral.dims","category":"page"},{"location":"spectralsparsegrids/","page":"Spectral Sparse Grids","title":"Spectral Sparse Grids","text":"The representation of the tensor of polynomials is compactly stored as a SparseVector. To index into this we require the storage dimension for each domain dimension.","category":"page"},{"location":"spectralsparsegrids/","page":"Spectral Sparse Grids","title":"Spectral Sparse Grids","text":"f_spectral.expansiondimensions","category":"page"},{"location":"spectralsparsegrids/","page":"Spectral Sparse Grids","title":"Spectral Sparse Grids","text":"This demonstrates that more polynomial terms are used in the parameter dimensions closer to one. Intuitively, this matches the anisotropic nature of the test function (see genz). The polynomial coefficients and the corresponding polynomial degrees are stored in sparse vectors.","category":"page"},{"location":"spectralsparsegrids/","page":"Spectral Sparse Grids","title":"Spectral Sparse Grids","text":"f_spectral.coefficients, f_spectral.polydegrees","category":"page"},{"location":"spectralsparsegrids/","page":"Spectral Sparse Grids","title":"Spectral Sparse Grids","text":"The spectral representation is the same function as the sparse grid representation.","category":"page"},{"location":"spectralsparsegrids/","page":"Spectral Sparse Grids","title":"Spectral Sparse Grids","text":"x_test = [rand(n) for i in 1:100]\ny_test = f_sg.(x_test)\ny_spectral = f_spectral.(x_test)\nall(isapprox(y_test, y_spectral; atol=1e-8))","category":"page"},{"location":"spectralsparsegrids/","page":"Spectral Sparse Grids","title":"Spectral Sparse Grids","text":"The spectral sparse grid approximation also supports addition and subtraction.","category":"page"},{"location":"spectralsparsegrids/","page":"Spectral Sparse Grids","title":"Spectral Sparse Grids","text":"f_spectral_2 = f_spectral + f_spectral\ny_spectral_2 = f_spectral_2.(x_test)\n\nall(isapprox(y_spectral_2, 2*y_spectral; atol=1e-8))","category":"page"},{"location":"spectralsparsegrids/","page":"Spectral Sparse Grids","title":"Spectral Sparse Grids","text":"f_spectral_0 = f_spectral - f_spectral\ny_spectral_0 = f_spectral_0.(x_test)\n@show y_spectral_0, f_spectral_0\n#all(isapprox(y_spectral_0, nothing; atol=1e-8))","category":"page"},{"location":"spectralsparsegrids/#Function-Reference","page":"Spectral Sparse Grids","title":"Function Reference","text":"","category":"section"},{"location":"spectralsparsegrids/#SparseGridsKit.SpectralSparseGridApproximation","page":"Spectral Sparse Grids","title":"SparseGridsKit.SpectralSparseGridApproximation","text":"SpectralSparseGridApproximation\n\nA spectral sparse grid approximation.\n\nFields\n\ndims::Int: Dimension of the domain.\nexpansiondimensions::Vector{Int}: Vector of maximum polynomial degree in each dimension.\npolytypes::Vector{Any}: Vector of polynomial spaces.\ncoefficients::SparseVector{Any}: SparseVector of polynomial coefficients\npolydegrees::SparseVector{Vector}: SparseVector of polynomial degrees for each non zero coefficient.\n\n\n\n\n\n","category":"type"},{"location":"spectralsparsegrids/#SparseGridsKit.SpectralSparseGridApproximation-NTuple{4, Any}","page":"Spectral Sparse Grids","title":"SparseGridsKit.SpectralSparseGridApproximation","text":"SpectralSparseGridApproximation(dims, expansionparams, polytypes, coefficients)\n\nConstructs a spectral sparse grid approximation.\n\nArguments\n\ndims::Int: Dimension of the domain.\nexpansiondimensions::Vector{Int}: Vector of maximum polynomial degree in each dimension.\npolytypes::Vector{Any}: Vector of polynomial spaces.\ncoefficients::Vector{Any}: Kronecker product vector of polynomial coefficients\ndomain::Vector{Vector{Real}}: Vector of domains for inputs\n\nReturns\n\nSpectralSparseGridApproximation: An instance of SpectralSparseGridApproximation.\n\n\n\n\n\n","category":"method"},{"location":"spectralsparsegrids/#SparseGridsKit.SpectralSparseGridApproximation-Tuple{Any}","page":"Spectral Sparse Grids","title":"SparseGridsKit.SpectralSparseGridApproximation","text":"(s::SpectralSparseGridApproximation)(x)\n\nEvaluate the spectral sparse grid approximation at the given point x.\n\nArguments\n\ns::SpectralSparseGridApproximation: Spectral sparse grid approximation object.\nx::Vector{T}: Vector x in domain to be evaluated\n\nReturns\n\nevaluation: Evaluation of s(x)\n\n\n\n\n\n","category":"method"},{"location":"spectralsparsegrids/#Base.:+-Tuple{SpectralSparseGridApproximation, SpectralSparseGridApproximation}","page":"Spectral Sparse Grids","title":"Base.:+","text":"+(grid1::SpectralSparseGridApproximation, grid2::SpectralSparseGridApproximation)\n\nAdd two SpectralSparseGridApproximation objects.\n\nArguments\n\ngrid1::SpectralSparseGridApproximation: Spectral sparse grid approximation.\ngrid2::SpectralSparseGridApproximation: Second spectral sparse grid approximation.\n\nReturns\n\nSpectralSparseGridApproximation representing sum of grid1 and grid2.\n\n\n\n\n\n","category":"method"},{"location":"spectralsparsegrids/#Base.:--Tuple{SpectralSparseGridApproximation, SpectralSparseGridApproximation}","page":"Spectral Sparse Grids","title":"Base.:-","text":"-(grid1::SpectralSparseGridApproximation, grid2::SpectralSparseGridApproximation)\n\nSubtracts SpectralSparseGridApproximation objects\n\nArguments\n\ngrid1::SpectralSparseGridApproximation: Spectral sparse grid approximation.\ngrid2::SpectralSparseGridApproximation: Second spectral sparse grid approximation, to be subtracted\n\nReturns\n\nSpectralSparseGridApproximation object representing the subtraction.\n\n\n\n\n\n","category":"method"},{"location":"spectralsparsegrids/#SparseGridsKit.convert_to_sg_approximation-Tuple{SpectralSparseGridApproximation, Any, Any}","page":"Spectral Sparse Grids","title":"SparseGridsKit.convert_to_sg_approximation","text":"convert_to_sg_approximation(ssg::SpectralSparseGridApproximation)\nConvert a `SpectralSparseGridApproximation` object to a SparseGridApproximation representation.\n\nArguments\n\nssg::SpectralSparseGridApproximation: Spectral sparse grid approximation.\n\nReturns\n\nSparseGridApproximation: Sparse grid approximation representation of ssg.\n\n\n\n\n\n","category":"method"},{"location":"spectralsparsegrids/#SparseGridsKit.convert_to_spectral_approximation-Tuple{SparseGrid, Any}","page":"Spectral Sparse Grids","title":"SparseGridsKit.convert_to_spectral_approximation","text":"convert_to_spectral_approximation(sparsegrid::SparseGrid, fongrid)\n\nConverts a sparse grid and corresponding evaluations fongrid to a SpectralSparseGridApproximation\n\nArguments\n\nsparsegrid::SparseGrid: Sparse grid\nfongrid: Function evaluations of sparse grid.\n\nReturns\n\nSpectralSparseGridApproximation represntation of sparsegrid with evaluations fongrid.\n\n\n\n\n\n","category":"method"},{"location":"spectralsparsegrids/#SparseGridsKit.convert_to_spectral_approximation-Tuple{SparseGridApproximation}","page":"Spectral Sparse Grids","title":"SparseGridsKit.convert_to_spectral_approximation","text":"convert_to_spectral_approximation(sga::SparseGridApproximation)\n\nConvert a SparseGridApproximation object to its spectral approximation.\n\nArguments\n\nsga::SparseGridApproximation: Sparse grid approximation.\n\nReturns\n\nSpectral Sparse Grid Approximation representing sga.\n\n\n\n\n\n","category":"method"},{"location":"spectralsparsegrids/#SparseGridsKit.getdomain-Tuple{Any}","page":"Spectral Sparse Grids","title":"SparseGridsKit.getdomain","text":"getdomain(polytype)\n\nTakes an ApproxFun polynomial space a returns a vector [a,b] of the domain endpoints.\n\nArguments\n\npolytype : ApproxFun Space\n\nReturns\n\ndomain : Vector domain [a,b]\n\n\n\n\n\n","category":"method"},{"location":"spectralsparsegrids/#SparseGridsKit.inverse_level_map-Tuple{Any, Any}","page":"Spectral Sparse Grids","title":"SparseGridsKit.inverse_level_map","text":"inverse_level_map(levelfunction, maxlevel)\nInverse level map for a given level2knots type function.\n\nArguments\n\nlevelfunction: Level function.\nmaxlevel: Maximum level.\n\nReturns\n\nVector{Int}: Inverse level map.\n\n\n\n\n\n","category":"method"},{"location":"spectralsparsegrids/#SparseGridsKit.kron_index-Tuple{Vector{Int64}, Vector{Int64}}","page":"Spectral Sparse Grids","title":"SparseGridsKit.kron_index","text":"kron_index(indices::Vector{Int}, dims::Vector{Int})\n\nCalculate the linear index in a Kronecker product space given the multi-dimensional indices and the dimensions of each space.\n\nArguments\n\nindices::Vector{Int}: Index vector.\ndims::Vector{Int}: Vector of storage dimension for each tensor dimension.\n\nReturns\n\nLinear index corresponding to the index given in indices.\n\n\n\n\n\n","category":"method"},{"location":"spectralsparsegrids/#SparseGridsKit.poly_Fun-Tuple{Any, Any}","page":"Spectral Sparse Grids","title":"SparseGridsKit.poly_Fun","text":"poly_Fun(knots, ind; lb=-1.0, ub=1.0)\n\nLagrange interpolation polynomial ind for the set of knots\n\nArguments\n\nknots::Vector{T}: A vector of knots\nind::Int: Knot index for polynomial equal to 1.\nlb::Float64: Domain lower bound. Default is -1.0.\nub::Float64: Domain upper bound. Default is 1.0.\n\nReturns\n\nf::Fun: Lagrange interpolation polynomial as ApproxFun Fun object.\n\n\n\n\n\n","category":"method"},{"location":"spectralsparsegrids/#SparseGridsKit.reverse_kron_index-Tuple{Int64, Vector{Int64}}","page":"Spectral Sparse Grids","title":"SparseGridsKit.reverse_kron_index","text":"reverse_kron_index(index::Int, dims::Vector{Int})\n\nGiven linear index index and a vector of dimensions dims, computes the multi-dimensional tensor index.\n\nArguments\n\nindex::Int: Linear index.\ndims::Vector{Int}: Vector containing the storage dimension of the tensor dimensions.\n\nReturns\n\nVector{Int}: Tensor index\n\n\n\n\n\n","category":"method"},{"location":"spectralsparsegrids/#SparseGridsKit.truncated_kron-Tuple{Any}","page":"Spectral Sparse Grids","title":"SparseGridsKit.truncated_kron","text":"truncated_kron(vectors; tol=1e-10)\n\nCompute the Kronecker product of a list of vectors with truncation.\n\nArguments\n\nvectors::Vector{Vector}: Vector of vectors to compute the Kronecker product.\ntol::Float64: Tolerance value for coefficienet truncation to promote sparsity. Elements with absolute values less than tol are set to zero. Default is 1e-15 to remove coefficients at machine precision.\n\nReturns\n\nresult: SparseVector representation of truncated Kronecker product of the input vectors.\ntensor_dims::Vector{Int}: Dimensions of the resulting tensor.\n\n\n\n\n\n","category":"method"},{"location":"knots/#Knots","page":"Knots","title":"Knots","text":"","category":"section"},{"location":"knots/#Knots-functions","page":"Knots","title":"Knots functions","text":"","category":"section"},{"location":"knots/","page":"Knots","title":"Knots","text":"The knot functions are of the form","category":"page"},{"location":"knots/","page":"Knots","title":"Knots","text":"x,w = knots(n)","category":"page"},{"location":"knots/","page":"Knots","title":"Knots","text":"where n is the number of knots required. The outputs are:","category":"page"},{"location":"knots/","page":"Knots","title":"Knots","text":"x the vector of knots,\nand w the vector of quadrature weights.","category":"page"},{"location":"knots/","page":"Knots","title":"Knots","text":"The quadrature weights are generally normalised to sum to one (i.e. representing a probability measure).","category":"page"},{"location":"knots/","page":"Knots","title":"Knots","text":"Often, one chooses to use Clenshaw–Curtis points which are available using the function CCPoints().","category":"page"},{"location":"knots/","page":"Knots","title":"Knots","text":"using SparseGridsKit, Plots\np = plot()\nfor ii in 1:2:7\n    plot!(CCPoints(); n=ii)\nend\nxlabel!(\"Clenshaw-Curtis Points\")","category":"page"},{"location":"knots/","page":"Knots","title":"Knots","text":"Knot functions can be mapped to other domains. Perhaps we wish to use Clenshaw-Curtis points on a parameter domain Gamma=0100.","category":"page"},{"location":"knots/","page":"Knots","title":"Knots","text":"a = 0\nb = 100\np = plot(CCPoints([a,b]))\nxlabel!(\"Clenshaw-Curtis Points\")","category":"page"},{"location":"knots/#Level-functions","page":"Knots","title":"Level functions","text":"","category":"section"},{"location":"knots/","page":"Knots","title":"Knots","text":"Additionally there are level functions mapping from a level l to a number of knots n. For example, we often use the approximate doubling rule","category":"page"},{"location":"knots/","page":"Knots","title":"Knots","text":"n(l) = 2^l-1 + 1 quad forall l  1","category":"page"},{"location":"knots/","page":"Knots","title":"Knots","text":"with n(1) = 1.","category":"page"},{"location":"knots/","page":"Knots","title":"Knots","text":"using SparseGridsKit\nDoubling()(1), Doubling()(2), Doubling()(3)","category":"page"},{"location":"knots/","page":"Knots","title":"Knots","text":"Note that sparsity in the construction is only attained when using nested sets of points. For Clenshaw-Curtis points this is achieved using the doubling rule.","category":"page"},{"location":"knots/","page":"Knots","title":"Knots","text":"using SparseGridsKit, Plots\np = plot()\nfor ii in 1:5\n    plot!(CCPoints(); n=Doubling()(ii))\nend\nxlabel!(\"Clenshaw-Curtis Points\")\nylabel!(\"Level\")","category":"page"},{"location":"knots/#More-knot-functions","page":"Knots","title":"More knot functions","text":"","category":"section"},{"location":"knots/","page":"Knots","title":"Knots","text":"Functionality is not restricted to knot functions included this package. For example, one could use the quadrature points provided in the FastGaussQuadrature.jl package. These can be wrapped in CustomPoints.","category":"page"},{"location":"knots/","page":"Knots","title":"Knots","text":"using SparseGridsKit, FastGaussQuadrature, Plots\n\nCustomGaussChebyshevPoints = CustomPoints([-1.0,1.0], n->gausschebyshevt(n))\nCustomGaussLegendrePoints = CustomPoints([-1.0,1.0], n->gausslegendre(n))\n\np = plot()\nplot!(CCPoints(); n=5)\nplot!(UniformPoints(); n=5)\nplot!(CustomGaussChebyshevPoints; n=5)\nplot!(CustomGaussLegendrePoints; n=5)","category":"page"},{"location":"knots/","page":"Knots","title":"Knots","text":"Leja points are also supplied. This currently either uses an discrete search based approach to iteratively construct points according to","category":"page"},{"location":"knots/","page":"Knots","title":"Knots","text":"z^k+1 = argmax_zin-11 v(z) prod_i=1^k abs(z-z^i)","category":"page"},{"location":"knots/","page":"Knots","title":"Knots","text":"where v(z) is the weight function, or a precomputed set for a uniform weight function. <!– Optimisation based points differ slightly to points generated using a discrete search. –> The default weight is v(z)= sqrt(rho(z)) for rho(z)=05 and unsymmetrical points.","category":"page"},{"location":"knots/","page":"Knots","title":"Knots","text":"using SparseGridsKit, Plots\n\np = plot()\nsymmetric = false\nv(z) = sqrt(0.5)\nplot!(LejaPoints(), label=\"default\")\nplot!(LejaPoints([-1,1],symmetric,:classic,v), label=\"unsymmetrical\")\nsymmetric = true\nplot!(LejaPoints([-1,1],symmetric,:classic), label=\"symmetrical\")\nplot!(LejaPoints([-1,1],symmetric,:precomputed), label=\"precomputed\")","category":"page"},{"location":"knots/#Function-Reference","page":"Knots","title":"Function Reference","text":"","category":"section"},{"location":"knots/#SparseGridsKit.CCPoints","page":"Knots","title":"SparseGridsKit.CCPoints","text":"CCPoints(domain::Vector{Real})\n\nGenerate Clenshaw–Curtis points on interval [domain[1] domain[2]].\n\nArguments\n\ndomain : Domain\n\nReturns\n\nCCPoints struct\n\n\n\n\n\n","category":"type"},{"location":"knots/#SparseGridsKit.CCPoints-Tuple{Any}","page":"Knots","title":"SparseGridsKit.CCPoints","text":"(p::CCPoints)(n)\n\nGenerate Clenshaw-Curtis points on domain.\n\nArguments\n\nn : Number of points\n\n\n\n\n\n","category":"method"},{"location":"knots/#SparseGridsKit.CustomLevel-Tuple{Any}","page":"Knots","title":"SparseGridsKit.CustomLevel","text":"(level::CustomLevel)(l)\n\nCustom rule\n\nArguments\n\nl : Level number\nfunction : Function to generate knots from n points\n\nReturns\n\n`n : Number of knots\n\n\n\n\n\n","category":"method"},{"location":"knots/#SparseGridsKit.CustomPoints","page":"Knots","title":"SparseGridsKit.CustomPoints","text":"CustomPoints(domain::Vector{Real}, knotsfunction::Function)\n\nGenerate custom points on interval [domain[1],domain[2]].\n\nArguments\n\ndomain : Domain\nknotsfunction : Function to generate knots from n points\n\nReturns\n\nCustomPoints struct\n\n\n\n\n\n","category":"type"},{"location":"knots/#SparseGridsKit.CustomPoints-Tuple{Any}","page":"Knots","title":"SparseGridsKit.CustomPoints","text":"(p::CustomPoints)(n)\n\nGenerate custom points on domain.\n\nArguments\n\nn : Number of points\n\n\n\n\n\n","category":"method"},{"location":"knots/#SparseGridsKit.Doubling-Tuple{Any}","page":"Knots","title":"SparseGridsKit.Doubling","text":"(level::Doubling)(l)\n\nDoubling rule\n\nArguments\n\nl : Level number\n\nReturns\n\n`n : Number of knots\n\n\n\n\n\n","category":"method"},{"location":"knots/#SparseGridsKit.GaussHermitePoints","page":"Knots","title":"SparseGridsKit.GaussHermitePoints","text":"GaussHermitePoints()\n\nGenerate Gauss–Hermite points.\n\nArguments\n\nNone\n\nReturns\n\nGaussHermitePoints struct\n\n\n\n\n\n","category":"type"},{"location":"knots/#SparseGridsKit.GaussHermitePoints-Tuple{Any}","page":"Knots","title":"SparseGridsKit.GaussHermitePoints","text":"(p::GaussHermitePoints)(n)\n\nGenerate Gauss-Hermite points on interval (-∞,∞).\n\nArguments\n\nn : Number of points\n\n\n\n\n\n","category":"method"},{"location":"knots/#SparseGridsKit.GaussLegendrePoints","page":"Knots","title":"SparseGridsKit.GaussLegendrePoints","text":"GaussLegendrePoints(domain::Vector{Real})\n\nGenerate Gauss–Legendre points on interval [domain[1],domain[2]].\n\nArguments\n\ndomain : Domain\n\nReturns\n\nGaussLegendrePoints struct\n\n\n\n\n\n","category":"type"},{"location":"knots/#SparseGridsKit.GaussLegendrePoints-Tuple{Any}","page":"Knots","title":"SparseGridsKit.GaussLegendrePoints","text":"(p::GaussLegendrePoints)(n)\n\nGenerate Gauss-Legendre points on domain.\n\nArguments\n\nn : Number of points\n\n\n\n\n\n","category":"method"},{"location":"knots/#SparseGridsKit.LejaPoints","page":"Knots","title":"SparseGridsKit.LejaPoints","text":"LejaPoints([a,b],type,v,symmetric)\nLejaPoints() = LejaPoints([-1,1], :precomputed, z->sqrt(0.5), false)\nLejaPoints(domain) = LejaPoints(domain, :precomputed, z->sqrt(0.5), false)\nLejaPoints(domain,type) = LejaPoints(domain,type, z->sqrt(0.5), false)\n\nGenerate Leja points on interval [domain[1],domain[2].\n\nArguments\n\ndomain : Domain\nsymmetric : Boolean indicating if the points are symmetric (default is false).\ntype : Type of Leja points (:precomputed or :classic), to use optimisation based or discrete search minimisation.\nv : Function to compute the weight function (default is sqrt(0.5)).\n\nReturns\n\nLejaPoints struct\n\n\n\n\n\n","category":"type"},{"location":"knots/#SparseGridsKit.LejaPoints-Tuple{Any}","page":"Knots","title":"SparseGridsKit.LejaPoints","text":"(p::LejaPoints)(n)\n\nGenerate Leja points on interval [a,b].\n\nArguments\n\nn : Number of points\n\n\n\n\n\n","category":"method"},{"location":"knots/#SparseGridsKit.Level-Tuple{Any}","page":"Knots","title":"SparseGridsKit.Level","text":"(level::Level)(n::Integer)\n\nLevel to knot number mapping\n\nArguments\n\nl : Level number\n\nReturns\n\n`n : Number of knots\n\n\n\n\n\n","category":"method"},{"location":"knots/#SparseGridsKit.Points-Tuple{Any}","page":"Knots","title":"SparseGridsKit.Points","text":"Points(n::Integer)\n\nGenerate knots on interval [a,b] using the specified generator function.\n\nArguments\n\nn : Number of points\n\n\n\n\n\n","category":"method"},{"location":"knots/#SparseGridsKit.Tripling-Tuple{Any}","page":"Knots","title":"SparseGridsKit.Tripling","text":"(level::Tripling)(l)\n\nTripling rule\n\nArguments\n\nl : Level number\n\nReturns\n\n`n : Number of knots\n\n\n\n\n\n","category":"method"},{"location":"knots/#SparseGridsKit.TwoStep-Tuple{Any}","page":"Knots","title":"SparseGridsKit.TwoStep","text":"(level::TwoStep)(l)\n\nTwoStep rule\n\nArguments\n\nl : Level number\n\nReturns\n\n`n : Number of knots\n\n\n\n\n\n","category":"method"},{"location":"knots/#SparseGridsKit.UniformPoints","page":"Knots","title":"SparseGridsKit.UniformPoints","text":"UniformPoints(domain::Vector{Real})\n\nGenerate uniform points on interval [domain[1],domain[2]].\n\nArguments\n\ndomain : Domain vector [a,b]\n\nReturns\n\nUniformPoints struct\n\n\n\n\n\n","category":"type"},{"location":"knots/#SparseGridsKit.UniformPoints-Tuple{Any}","page":"Knots","title":"SparseGridsKit.UniformPoints","text":"(p::UniformPoints)(n)\n\nGenerate uniform points on domain.\n\nArguments\n\nn : Number of points\n\n\n\n\n\n","category":"method"},{"location":"sparsegridintegration/#Sparse-Grid-Integration","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"","category":"section"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"Sparse grid interpolation in SparseGridsKit.jl relies on precomputed integrals of the underlying approximation functions.","category":"page"},{"location":"sparsegridintegration/#Sparse-Grid-Integration-2","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"","category":"section"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"To integrate a sparse grid polynomial approximation we require the sparse grid, function evaluations and the precomputed integrals.","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"Consider the function f-11tomathbbR","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"f(x) = @. 3.0*x^2 + 2.0*x + 1.0","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"and we construct the two-dimension function f(x_1) f(x_2)^2^top mapping -11^2 to mathbbR^2. We seek the value of the integral","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"int_Gamma f(x_1) f(x_2)^2^top rho(x) textrmd x","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"for a weight function rho(x)=05^2.","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"The constant approximation is f(x)approx11. The approximate integral using the constant approximation is equal to 11.","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"using SparseGridsKit\nn,k = 2,0\nmi_set = create_smolyak_miset(n,k)\n\nsg = create_sparsegrid(mi_set)\nf_on_grid = [[f(x[1]), f(x[2])^2] for x in get_grid_points(sg)]\n# Test integrate_on_sparsegrid\nintegral_result = integrate_on_sparsegrid(sg, f_on_grid)\nintegral_result ≈ [1, 1]","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"The estimated integral is improved by using a sparse grid with more grid points. The integral can be evaluated explicitly, and it is seen that using an larger sparse grid gets the correct result 209215.","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"n,k = 2,4\nmi_set = create_smolyak_miset(n,k)\nsg = create_sparsegrid(mi_set)\nf_on_grid = [[f(x[1]), f(x[2])^2] for x in get_grid_points(sg)]\n# Test integrate_on_sparsegrid\nintegral_result = integrate_on_sparsegrid(sg, f_on_grid)\nintegral_result ≈ [2.0,92/15]","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"This is of course expected –- the polynomial approximation space represented by the larger sparse grid contains the function  f(x_1) f(x_2)^2.","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"Underlying the integral is the computation of quadrature weights. The SparseGrid structure is initialised without weights, which can be computed using compute_quadrature_weights!. This is done automatically within integrate_on_sparsegrid if the quadrature weights have not been computed.","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"compute_quadrature_weights!(sg)\nsg.quadrature_weights","category":"page"},{"location":"sparsegridintegration/#Sparse-Grid-Weighted-L_{\\rho}2(\\Gamma)-Norms","page":"Sparse Grid Integration","title":"Sparse Grid Weighted L_{\\rho}^2(\\Gamma) Norms","text":"","category":"section"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"Often the weighted L_rho^2(Gamma) norm is required. Squaring a polynomial approximation results in many higher degree polynomial terms –- it is not as simple as squaring the evaluations at each sparse grid point.","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"To do this efficiently, integrals of the products of interpolation polynomials is precomputed. A maximum level number is selected and for each domain dimension all pairwise L_rho^2(Gamma) integrals inner products are computed using precompute_lagrange_integrals. For example, we can then extract the pairwise inner products for the level 2 and level 3 polynomials.","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"    using SparseGridsKit, LinearAlgebra\n    pcl = precompute_lagrange_integrals(7)\n    level1 = 2\n    level2 = 3\n    domaindim = 1\n    pcl[domaindim][level1,level2,:,:]","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"This precomputation step is generally not too expensive but uses a moderate amount of memory.","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"@elapsed precompute_lagrange_integrals(7)","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"sizeof(pcl)","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"Additional arguments must be provided to  precompute_lagrange_integrals if specific knot types are use.","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"The precomputed L_rho^2(Gamma) integrals from precompute_lagrange_integrals are used with the sparse grid approximation structure to exactly compute the L_rho^2(Gamma) norm of a sparse grid polynomial function. These are paired with appropriate pairwise products of the function evaluation which are computed with precompute_pairwise_norms. For example, for a scalar valued function we may require","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"f(x_1) f(x_2) forall x_1x_2 in Z","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"where Z is the set of sparse grid points.","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"For example, the function f(x)=x has the weighted L_rho^2(-11) norm equal to ","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"Vert x^2 Vert_L_rho^2(-11) = sqrt3","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"for weight function rho=05.","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"n,k = 1,1\nmi_set = create_smolyak_miset(n,k)\npcl = precompute_lagrange_integrals(7)\n\nsg = create_sparsegrid(mi_set)\nf_on_grid = [[x[1]] for x in get_grid_points(sg)]\npairwise_norms = precompute_pairwise_norms(f_on_grid, product=(x,y)->dot(x,y))\nl2_integral_result = integrate_L2_on_sparsegrid(sg, f_on_grid, pcl)\nl2_integral_result[1] ≈ sqrt(1/3)","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"Similarly, for x^2 we get","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"Vert x^2 Vert_L_rho^2(-11)=sqrt5","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"n,k = 1,3\nmi_set = create_smolyak_miset(n,k)\npcl = precompute_lagrange_integrals(7)\n\nsg = create_sparsegrid(mi_set)\nf_on_grid = [[x[1]^2] for x in get_grid_points(sg)]\nl2_integral_result = integrate_L2_on_sparsegrid(sg, f_on_grid, pcl)\nl2_integral_result[1] ≈ sqrt(1/5)","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"Finally we consider the L^2_rho(-11^2) norm of f(x_1). This can be explicitly computed to be sqrt9215.","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"n,k = 2,4\nmi_set = create_smolyak_miset(n,k)\npcl = precompute_lagrange_integrals(7)\n\nsg = create_sparsegrid(mi_set)\nf_on_grid = [f(x[1]) for x in get_grid_points(sg)]\npairwise_norms = precompute_pairwise_norms(f_on_grid, product=(x,y)->x.*y)\nl2_integral_result = integrate_L2_on_sparsegrid(sg, f_on_grid, pcl)\nl2_integral_result ≈ sqrt(92/15)","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"If the evaluation of the function fGammamapstoR^n represents a discrete approximation of a function F, we may use a mass matrix Q to compute","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"(x_1^top Q x_2)^12 quad forall x_1x_2 in Z","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"This is useful for integrals of the type L^2_rho(Gamma L^2(D)) where D represents the domain of the approximated function F and is often seen in the approximation of parametric PDE solutions. This is achieved by passing product=(x,y)->dot(x,Q,y) as an argument in precompute_pairwise_norms. ","category":"page"},{"location":"sparsegridintegration/#Function-Reference","page":"Sparse Grid Integration","title":"Function Reference","text":"","category":"section"},{"location":"sparsegridintegration/#SparseGridsKit.integrate_on_sparsegrid","page":"Sparse Grid Integration","title":"SparseGridsKit.integrate_on_sparsegrid","text":"integrate_on_sparsegrid(sg, f_on_grid, precomputed_lagrange_integrals)\n\nIntegrates a function (f_on_grid) over a sparse grid (sg) using precomputed Lagrange integrals.\n\nArguments\n\nsg: The sparse grid for integration.\nf_on_grid: A vector of function values on the sparse grid.\n\nReturns\n\nThe integral of the function over the sparse grid.\n\n\n\n\n\n","category":"function"},{"location":"sparsegridintegration/#SparseGridsKit.integrate_L2_on_sparsegrid","page":"Sparse Grid Integration","title":"SparseGridsKit.integrate_L2_on_sparsegrid","text":"integrate_L2_on_sparsegrid(sg, f_on_grid, precomputed_lagrange_integrals; product=dot, precomputed_pairwise_norms=nothing)\n\nComputes the L2 norm of a function (f_on_grid) over a sparse grid (sg) using precomputed integrals.\n\nArguments\n\nsg: The sparse grid.\nf_on_grid: A vector of function values on the sparse grid.\nprecomputed_lagrange_integrals: Precomputed Lagrange integrals.\nproduct: A function to compute the inner product (default is dot).\nprecomputed_pairwise_norms: Optional precomputed norms for optimization.\n\nReturns\n\nThe L2 norm of the function over the sparse grid.\n\n\n\n\n\n","category":"function"},{"location":"umbridge/#UM-Bridge","page":"UM-Bridge","title":"UM-Bridge","text":"","category":"section"},{"location":"umbridge/","page":"UM-Bridge","title":"UM-Bridge","text":"It is also possible to connect the 'SparseGridsKit.jl' to any model via the 'UM-Bridge' Julia client.","category":"page"},{"location":"umbridge/","page":"UM-Bridge","title":"UM-Bridge","text":"The required setup is sketched below.","category":"page"},{"location":"umbridge/","page":"UM-Bridge","title":"UM-Bridge","text":"using UMBridge\nusing SparseGridsKit\n\nurl = \"model.url:port\"\n\n# Set up a model \"modelname\"\nmodel = UMBridge.HTTPModel(\"modelname\", url)\n\n# Create sparse grid\nn=1\nk=5\nmi = create_smolyak_miset(n,k)\nsg = create_sparsegrid(mi)\n\nZ = get_grid_points(sg)\n\n# Model evaluation with configuration parameters\nconfig = Dict(\"Config1\" => 1);\n\nf_on_Z = [UMBridge.evaluate(model, [map(z[1])], config) for z in Z]","category":"page"},{"location":"plots/#Plots","page":"Plotting","title":"Plots","text":"","category":"section"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"Plotting functionality is provided via `Plots.jl and its Recipies.","category":"page"},{"location":"plots/#Knots","page":"Plotting","title":"Knots","text":"","category":"section"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"For the knot functions inheriting from the abstract type Points plotting is supported. This defaults to 11 points.","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"using SparseGridsKit, Plots\n\np = plot(CCPoints([-3,3]))\nplot!(CCPoints([-3,3]); n=21)","category":"page"},{"location":"plots/#Multi-Index-Set","page":"Plotting","title":"Multi-Index Set","text":"","category":"section"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"For multi-index type MISet pairwise scatter plots for each dimension can be produced.","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"miset = create_smolyak_miset(3,3)\np = misetplot(miset)","category":"page"},{"location":"plots/#Sparse-Grids","page":"Plotting","title":"Sparse Grids","text":"","category":"section"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"Sparse grid points in a SparseGrid can be plotted. This has an optional arguement to select which indices are plotted which is useful in dimensions greater than 3.","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"sg = create_sparsegrid(miset)\np = plot(sg; targetdims=[3,2,1])","category":"page"},{"location":"plots/#Sparse-Grid-Approximations","page":"Plotting","title":"Sparse Grid Approximations","text":"","category":"section"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"Sparse grid approximations, consisting of function values and a polynomial approximation space can also be plotted.","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"f(x) = x[1]^5 + cos(x[2]) + abs(x[3])\nf_on_sg = f.(get_grid_points(sg))\n\nsga = SparseGridApproximation(sg,f_on_sg)\nssg = convert_to_spectral_approximation(sga)\n\np = plot(\n    plot(sga; fill=true, title=\"fill=true\"),\n    plot(sga; targetdims=[2,3],title=\"targetdims\"),\n    plot(ssg; color=:turbo, fill=true, title=\":turbo\"),\n    plot(ssg; seriestype=:surface, targetdims=[2,3], title=\"surface\"),\n    layout = (2,2)\n)","category":"page"},{"location":"plots/#Function-Reference","page":"Plotting","title":"Function Reference","text":"","category":"section"},{"location":"plots/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, Points}","page":"Plotting","title":"RecipesBase.apply_recipe","text":"f(p::Points; n = 11)\n\nRecipe to plot scatter of knots and weights.\n\nArguments\n\np::Points: Points object.\nn::Int: (Optional) Number of knots. Defaults to 11.\n\n\n\n\n\n","category":"method"},{"location":"plots/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, SparseGrid}","page":"Plotting","title":"RecipesBase.apply_recipe","text":"f(sg::SparseGrid; targetdims=[1,2,3])\n\nRecipe to convert sparse grid to set of x,y,z points in dimensions given by targetdims\n\nArguments\n\nsg : Sparse grid\ntargetdims : (Optional) Cross section dimensions\n\n\n\n\n\n","category":"method"},{"location":"plots/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, Union{SparseGridApproximation, SpectralSparseGridApproximation}}","page":"Plotting","title":"RecipesBase.apply_recipe","text":"f(sga::SparseGridApproximation)\nf(sg::SpectralSparseGridApproximation)\n\nRecipe for plotting approximations based on sparse grids. For more than two dimensions it is a slice with the other parameters fixed at the midpoint.\n\n\n\n\n\n","category":"method"},{"location":"plots/#SparseGridsKit.misetplot!-Tuple","page":"Plotting","title":"SparseGridsKit.misetplot!","text":"misetplot(miset::MISet)\n\nScatter plot of MI in pairs of dimensions\n\nArguments\n\nmiset : Multi-index set to plot\n\n\n\n\n\n","category":"method"},{"location":"plots/#SparseGridsKit.misetplot!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}","page":"Plotting","title":"SparseGridsKit.misetplot!","text":"misetplot(miset::MISet)\n\nScatter plot of MI in pairs of dimensions\n\nArguments\n\nmiset : Multi-index set to plot\n\n\n\n\n\n","category":"method"},{"location":"plots/#SparseGridsKit.misetplot-Tuple","page":"Plotting","title":"SparseGridsKit.misetplot","text":"misetplot(miset::MISet)\n\nScatter plot of MI in pairs of dimensions\n\nArguments\n\nmiset : Multi-index set to plot\n\n\n\n\n\n","category":"method"},{"location":"multifidelity/#Multi-fidelity-Modelling","page":"Multi-Fidelity Sparse Grid Approximation","title":"Multi-fidelity Modelling","text":"","category":"section"},{"location":"multifidelity/","page":"Multi-Fidelity Sparse Grid Approximation","title":"Multi-Fidelity Sparse Grid Approximation","text":"The construction offers support for multi-fidelity modelling. A special type of knot function is included which simply maps a level to the same integer, to then be use to specify the model. This has a weight w=10 and a corresponding polynomial equal to 1 for all inputs. In practice, for interpolation there is no parameter to be evaluated, but this set up provides the correct multi-fidelity structure using the existing single fidelity construction.","category":"page"},{"location":"multifidelity/","page":"Multi-Fidelity Sparse Grid Approximation","title":"Multi-Fidelity Sparse Grid Approximation","text":"using SparseGridsKit\nFidelityPoints()(3), Fidelity()(3)","category":"page"},{"location":"multifidelity/","page":"Multi-Fidelity Sparse Grid Approximation","title":"Multi-Fidelity Sparse Grid Approximation","text":"A simple multi-fidelity model considers a constant function f(x)=y_1^2 + sin(y_2) + y_3, subject to errors 10^-alpha. Functions are specified a f(vecalphavecy) where the vector vecalpha controls the fidelity and vecy is simply the parameter as usual.","category":"page"},{"location":"multifidelity/","page":"Multi-Fidelity Sparse Grid Approximation","title":"Multi-Fidelity Sparse Grid Approximation","text":"f(y) = y[1]^2 + sin(y[2]) + y[3]\n\nnfid = 1\nnparams = 3\nf_fidelities(alpha,y) = f(y) + 10^(-alpha[1])","category":"page"},{"location":"multifidelity/","page":"Multi-Fidelity Sparse Grid Approximation","title":"Multi-Fidelity Sparse Grid Approximation","text":"The rule for fidelity is (Fidelity)(@ref). This returns 1 for all input levels as there is only one model per level. The knots are FidelityPoints, which returns the input value plus a weight zero. The knot function is treated as a special case in the sparse grid construction.","category":"page"},{"location":"multifidelity/","page":"Multi-Fidelity Sparse Grid Approximation","title":"Multi-Fidelity Sparse Grid Approximation","text":"maxfidelity = 5\nrule = [fill(Fidelity(),nfid)..., fill(Doubling(),nparams)...]\nknots = [fill(FidelityPoints(),nfid)..., fill(CCPoints(),nparams)...]","category":"page"},{"location":"multifidelity/","page":"Multi-Fidelity Sparse Grid Approximation","title":"Multi-Fidelity Sparse Grid Approximation","text":"We wrap the function f using multifidelityfunctionwrapper. This allows the user to use the single fidelity sparse grid construction, with function calls separated as z=vecalphavecy.","category":"page"},{"location":"multifidelity/","page":"Multi-Fidelity Sparse Grid Approximation","title":"Multi-Fidelity Sparse Grid Approximation","text":"f_wrapped = multifidelityfunctionwrapper(f_fidelities,knots)\n\nMI = create_smolyak_miset(nfid+nparams,2)\n\nsg = create_sparsegrid(MI; knots=knots, rule=rule)\n@show get_grid_points(sg)\n@show f_eval = f_wrapped.(get_grid_points(sg))","category":"page"},{"location":"multifidelity/","page":"Multi-Fidelity Sparse Grid Approximation","title":"Multi-Fidelity Sparse Grid Approximation","text":"Finally, interpolation and integration are possible on the sparse grid. Interpolation currently requires dummy values to give a complete parameter vector vecalpha vecy. In the future this may be simplified.","category":"page"},{"location":"multifidelity/","page":"Multi-Fidelity Sparse Grid Approximation","title":"Multi-Fidelity Sparse Grid Approximation","text":"interpolate_on_sparsegrid(sg, f_eval, [[fill(1,nfid)..., fill(0.0,nparams)...]])\n\npcl = precompute_lagrange_integrals(5, knots, rule)\n\nf_on_grid = f_wrapped.(get_grid_points(sg))\n\n# Test integrate_on_sparsegrid\nintegral_result = integrate_on_sparsegrid(sg, f_on_grid)","category":"page"},{"location":"multifidelity/","page":"Multi-Fidelity Sparse Grid Approximation","title":"Multi-Fidelity Sparse Grid Approximation","text":"It is also possible to use the adaptive sparse grid construction. A costfunction can be supplied to give a representative cost for each fidelity. This acts on a vector vecα of the fidelities. We must supply knots and rules explictly so that the algorithm can distinguish between model and input dimensions.","category":"page"},{"location":"multifidelity/","page":"Multi-Fidelity Sparse Grid Approximation","title":"Multi-Fidelity Sparse Grid Approximation","text":"knots = [fill(FidelityPoints(),nfid)..., fill(CCPoints(),nparams)...]\nrule = [fill(Fidelity(),nfid)..., fill(Doubling(),nparams)...]\n(sg, f_on_Z) = adaptive_sparsegrid(f_wrapped, nfid + nparams; maxpts = 100, proftol=1e-4, rule = rule, knots = knots, θ=1e-4, type=:deltaint, costfunction=α->10^prod(α))","category":"page"},{"location":"multifidelity/#Function-Reference","page":"Multi-Fidelity Sparse Grid Approximation","title":"Function Reference","text":"","category":"section"},{"location":"multifidelity/#SparseGridsKit.Fidelity-Tuple{Any}","page":"Multi-Fidelity Sparse Grid Approximation","title":"SparseGridsKit.Fidelity","text":"(f:Fidelity)(l)\n\nFidelity level to knot number mapping\n\nArguments\n\nl : Fidelity level\n\nReturns\n\n1: Fidelity level always returns 1\n\n\n\n\n\n","category":"method"},{"location":"multifidelity/#SparseGridsKit.FidelityPoints-Tuple{Any}","page":"Multi-Fidelity Sparse Grid Approximation","title":"SparseGridsKit.FidelityPoints","text":"(p::FidelityPoints)(n)\n\nGenerate fidelity points\n\nArguments\n\nn : Number of points\n\n\n\n\n\n","category":"method"},{"location":"multifidelity/#SparseGridsKit.FidelityPoints-Tuple{}","page":"Multi-Fidelity Sparse Grid Approximation","title":"SparseGridsKit.FidelityPoints","text":"FidelityPoints()\n\nGenerate a struct for fidelity points\n\nReturns\n\nFidelityPoints struct\n\n\n\n\n\n","category":"method"},{"location":"multifidelity/#SparseGridsKit.fidelitymap-Tuple{Any, Any, Any}","page":"Multi-Fidelity Sparse Grid Approximation","title":"SparseGridsKit.fidelitymap","text":"fidelitymap(y, nfid, nparam)\n\nSplits a grid point y to y[1:nfid],y[nfid+1:nfid+nparam]\n\nArguments\n\ny: Grid point\nnfid: Number of fidelity indices\nnparam: Number of parameters\n\nReturns\n\nyfid : fidelity indices\nyparam : parameters\n\n\n\n\n\n","category":"method"},{"location":"multifidelity/#SparseGridsKit.fidelitypoints-Tuple{Any}","page":"Multi-Fidelity Sparse Grid Approximation","title":"SparseGridsKit.fidelitypoints","text":"fidelitypoints(n)\n\nGenerate indexes as Natural numbers 1,2,3,... for use as fidelity levels\n\nArguments\n\nn: Fidelity index.\n\nReturns\n\nz : n\nw : 1.0\n\n\n\n\n\n","category":"method"},{"location":"multifidelity/#SparseGridsKit.multifidelityfunctionwrapper-Tuple{Any, Any}","page":"Multi-Fidelity Sparse Grid Approximation","title":"SparseGridsKit.multifidelityfunctionwrapper","text":"multifidelityfunctionwrapper(f, nfid, nparam)\n\nWrap a function for multifidelity evaluation\n\nArguments\n\nf: Function to wrap\nz: Grid point\nnfid: Number of fidelity indices\nnparam: Number of parameters\n\n\n\n\n\n","category":"method"},{"location":"bib/#References","page":"References","title":"References","text":"","category":"section"},{"location":"bib/","page":"References","title":"References","text":"S. A. Smolyak. Quadrature and interpolation formulae on tensor products of certain function classes. Soviet Math. Dokl. 4, 240–243 (1963).\n\n\n\nV. Barthelmann, E. Novak and K. Ritter. High dimensional polynomial interpolation on sparse grids. Advances in Computational Mathematics 12, 273–288 (2000).\n\n\n\nT. Gerstner and M. Griebel. Numerical integration using sparse grids. Numerical algorithms 18, 209–232 (1998).\n\n\n\nT. Gerstner and M. Griebel. Dimension–Adaptive Tensor–Product Quadrature. Computing 71, 65–87 (2003).\n\n\n\nC. Piazzola and L. Tamellini. Algorithm 1040: The Sparse Grids Matlab Kit - a Matlab implementation of sparse grids for high-dimensional function approximation and uncertainty quantification. ACM Transactions on Mathematical Software 50 (2024).\n\n\n\n","category":"page"},{"location":"differentiation/#Differentiation","page":"Approximation Differentiation","title":"Differentiation","text":"","category":"section"},{"location":"differentiation/","page":"Approximation Differentiation","title":"Approximation Differentiation","text":"Differentiation is supported for scalar valued functions currently. This is achieved using DifferentiationInterface.jl.","category":"page"},{"location":"differentiation/","page":"Approximation Differentiation","title":"Approximation Differentiation","text":"using SparseGridsKit, ForwardDiff\nn = 2\np(x) = [3*x[1]^3*x[2]^2]\np_prime(x) = [9*x[1]^2*x[2]^2 6*x[1]^3*x[2]]\n\nsg = create_sparsegrid(create_smolyak_miset(n, 4))\nf_on_Z = p.(get_grid_points(sg))\nf_sga = SparseGridApproximation(sg, f_on_Z)\nf_sg_diff = derivative(f_sga)\n\n# Create test points\ntest_points = [[x,y] for x in range(-1, stop=1, length=10) for y in range(-1, stop=1, length=10)]\n# Evaluate the original function and its derivative at the test points\nf_test = p_prime.(test_points)\nf_test_diff = f_sg_diff.(test_points)\nerror = abs.(sum(f_test - f_test_diff))\nprintln(\"Error: $error\")","category":"page"},{"location":"differentiation/#Function-Reference","page":"Approximation Differentiation","title":"Function Reference","text":"","category":"section"},{"location":"differentiation/#SparseGridsKit.derivative-Tuple{SparseGrid, Vector}","page":"Approximation Differentiation","title":"SparseGridsKit.derivative","text":"derivative(sg::SparseGrid, f_on_z::Vector)\n\nComputes the derivative of a function defined on a sparse grid.\n\nArguments\n\nsg: A sparse grid object.\nf_on_z: A vector of function values on the sparse grid.\n\nReturns\n\nA tuple containing the sparse grid and the derivative values on the grid.\n\n\n\n\n\n","category":"method"},{"location":"differentiation/#SparseGridsKit.derivative-Tuple{SparseGridApproximation}","page":"Approximation Differentiation","title":"SparseGridsKit.derivative","text":"derivative(sga::SparseGridApproximation)\n\nComputes the derivative of a SparseGridApproximation object.\n\nArguments\n\nsga: An instance of SparseGridApproximation.\n\nReturns\n\n-SparseGridApproximation object representing the derivative.\n\n\n\n\n\n","category":"method"},{"location":"differentiation/#SparseGridsKit.derivative-Tuple{SpectralSparseGridApproximation}","page":"Approximation Differentiation","title":"SparseGridsKit.derivative","text":"derivative(ssg::SpectralSparseGridApproximation; sparsegrid=nothing)\n\nComputes the derivative of a SpectralSparseGridApproximation object.\n\nArguments\n\nssg: An instance of SpectralSparseGridApproximation.\nsparsegrid: Optional sparse grid to use for differentiation.\n\nReturns\n\nA SpectralSparseGridApproximation object representing the derivative.\n\n\n\n\n\n","category":"method"},{"location":"sparsegrids/#Sparse-Grids","page":"Sparse Grids","title":"Sparse Grids","text":"","category":"section"},{"location":"sparsegrids/","page":"Sparse Grids","title":"Sparse Grids","text":"Knot functions, level functions and multi-index sets are combined to define a sparse grid structure.","category":"page"},{"location":"sparsegrids/#Simple-Sparse-Grids","page":"Sparse Grids","title":"Simple Sparse Grids","text":"","category":"section"},{"location":"sparsegrids/","page":"Sparse Grids","title":"Sparse Grids","text":"In the simplest case one often wants to create a sparse grid using a sequence of nested sets Clenshaw–Curtis points and a Smolyak type multi-index set. To this end, one uses create_sparsegrid with the desired Smolyak multi-index set.","category":"page"},{"location":"sparsegrids/","page":"Sparse Grids","title":"Sparse Grids","text":"using SparseGridsKit\n\nn, k = 2, 1\nmi_set = create_smolyak_miset(n, k)\nsg = create_sparsegrid(mi_set)\npropertynames(sg)","category":"page"},{"location":"sparsegrids/","page":"Sparse Grids","title":"Sparse Grids","text":"The grid points can be extracted using the get_grid_points function. This returns a vector of vector points.","category":"page"},{"location":"sparsegrids/","page":"Sparse Grids","title":"Sparse Grids","text":"points = get_grid_points(sg)","category":"page"},{"location":"sparsegrids/","page":"Sparse Grids","title":"Sparse Grids","text":"using Plots, LaTeXStrings\nplot(sg)\nplot!(title=\"Sparse Grid n,k=\"*string(n)*\",\"*string(k),\n        xlabel=L\"y_1\",\n        ylabel=L\"y_2\")","category":"page"},{"location":"sparsegrids/","page":"Sparse Grids","title":"Sparse Grids","text":"The grid can be altered by adding additional multi-indices.","category":"page"},{"location":"sparsegrids/","page":"Sparse Grids","title":"Sparse Grids","text":"mi_set_new = MISet([[1,3]]) \ncombined_mi_set = add_mi(mi_set, mi_set_new)\nsg_combined = create_sparsegrid(combined_mi_set)\n\npoints = get_grid_points(sg_combined)\n\nx = [p[1] for p in points]\ny = [p[2] for p in points]\n\nplot(sg_combined)\nplot!(  title=\"Sparse Grid Combined\",\n        xlabel=\"y_1\",\n        ylabel=\"y_2\")","category":"page"},{"location":"sparsegrids/","page":"Sparse Grids","title":"Sparse Grids","text":"More complex grids can be constructed. For example consider increasing the dimension n and using more multi-indices in the multi-index set. ","category":"page"},{"location":"sparsegrids/","page":"Sparse Grids","title":"Sparse Grids","text":"n, k = 3, 3\nmi_set = create_smolyak_miset(n, k)\nsg = create_sparsegrid(mi_set)\npoints = get_grid_points(sg)","category":"page"},{"location":"sparsegrids/","page":"Sparse Grids","title":"Sparse Grids","text":"This can still be easily visualised.","category":"page"},{"location":"sparsegrids/","page":"Sparse Grids","title":"Sparse Grids","text":"nsteps = 100\n@gif for i in range(0, stop = 2π, length = nsteps)\n        plot(sg)\n        plot!(title=\"Sparse Grid n,k=\"*string(n)*\",\"*string(k),\n                xlabel=L\"y_1\",\n                ylabel=L\"y_2\",\n                zlabel=L\"y_3\",\n                camera = (20 * (1 + cos(i)),10 * (1 + cos(i))))\nend","category":"page"},{"location":"sparsegrids/#Mixed-Knots-Sparse-Grids","page":"Sparse Grids","title":"Mixed Knots Sparse Grids","text":"","category":"section"},{"location":"sparsegrids/","page":"Sparse Grids","title":"Sparse Grids","text":"It is possible to mix the type of points in a grid. To demonstrate, consider linear points nmapsto12n in the first dimension, Clenshaw–Curtis points on a domain Gamma_2=0100 in the second dimension and uniformly spaced points on the domain -11  in the third dimension.","category":"page"},{"location":"sparsegrids/","page":"Sparse Grids","title":"Sparse Grids","text":"using SparseGridsKit, Plots, LaTeXStrings\n# Test create_sparsegrid\nn,k =3,3\nknots = [CCPoints(), CCPoints([0,100]), UniformPoints()]\nrules = [Doubling(), Doubling(), Linear()]\nmi_set = create_smolyak_miset(n,k)\nsg = create_sparsegrid(mi_set, knots=knots, rule=rules)\nnsteps = 100\n@gif for i in range(0, stop = 2π, length = nsteps)\n        plot(sg)\n        plot!(\n                title=\"Sparse Grid n,k=\"*string(n)*\",\"*string(k),\n                xlabel=L\"y_1\",\n                ylabel=L\"y_2\",\n                zlabel=L\"y_3\",\n                camera = (20 * (1 + cos(i)),10 * (1 + cos(i)))\n                )\nend","category":"page"},{"location":"sparsegrids/#Function-Reference","page":"Sparse Grids","title":"Function Reference","text":"","category":"section"},{"location":"sparsegrids/#SparseGridsKit.compute_quadrature_weights!-Tuple{Any}","page":"Sparse Grids","title":"SparseGridsKit.compute_quadrature_weights!","text":"computequadratureweights(sg) Computes the quadrature weights for a sparse grid (sg).\n\nArguments\n\nsg: The sparse grid for which to compute the quadrature weights.\n\nReturns\n\nUpdates the quadrature_weights field of the sparse grid with computed weights.\n\n\n\n\n\n","category":"method"},{"location":"sparsegrids/#SparseGridsKit.create_sparsegrid-Tuple{Any}","page":"Sparse Grids","title":"SparseGridsKit.create_sparsegrid","text":"create_sparsegrid(mi_set; rule=Doubling(), knots=CCPoints())\n\nCreates a sparse grid based on the provided multi-index set (mi_set).\n\nArguments\n\nmi_set: An instance of MISet containing the multi-index set for grid construction.\nrule: Map from index to number of points. Optional (default Doubling()). Function or vector of functions (for each dimension).\nknots: Type of knots. Optional (default Clenshaw–Curtis). Function or vector of functions (for each dimension).\n\nReturns\n\nA sparse grid object constructed using the specified multi-index set.\n\n\n\n\n\n","category":"method"},{"location":"sparsegrids/#SparseGridsKit.get_grid_points-Tuple{Any}","page":"Sparse Grids","title":"SparseGridsKit.get_grid_points","text":"get_grid_points(sg)\n\nRetrieves the grid points from a sparse grid (sg).\n\nArguments\n\nsg: A sparse grid object.\n\nReturns\n\nA vector of vectors, where each inner vector represents a grid point.\n\n\n\n\n\n","category":"method"},{"location":"sparsegrids/#SparseGridsKit.get_mi_set-Tuple{Any}","page":"Sparse Grids","title":"SparseGridsKit.get_mi_set","text":"get_mi_set(sg)\n\nGets set of multi-indices from a sparse grid (sg).\n\nArguments\n\nsg: A sparse grid object.\n\nReturns\n\nAn MISet containing the downwards-closed set of multi-indices.\n\n\n\n\n\n","category":"method"},{"location":"sparsegrids/#SparseGridsKit.get_n_grid_points-Tuple{Any}","page":"Sparse Grids","title":"SparseGridsKit.get_n_grid_points","text":"get_n_grid_points(sg)\n\nReturns the number of grid points in the sparse grid (sg).\n\nArguments\n\nsg: A sparse grid object.\n\nReturns\n\nThe number of grid points in the sparse grid.\n\n\n\n\n\n","category":"method"},{"location":"sparsegrids/#SparseGridsKit.integrate_L2_on_sparsegrid-Tuple{Any, Any, Any}","page":"Sparse Grids","title":"SparseGridsKit.integrate_L2_on_sparsegrid","text":"integrate_L2_on_sparsegrid(sg, f_on_grid, precomputed_lagrange_integrals; product=dot, precomputed_pairwise_norms=nothing)\n\nComputes the L2 norm of a function (f_on_grid) over a sparse grid (sg) using precomputed integrals.\n\nArguments\n\nsg: The sparse grid.\nf_on_grid: A vector of function values on the sparse grid.\nprecomputed_lagrange_integrals: Precomputed Lagrange integrals.\nproduct: A function to compute the inner product (default is dot).\nprecomputed_pairwise_norms: Optional precomputed norms for optimization.\n\nReturns\n\nThe L2 norm of the function over the sparse grid.\n\n\n\n\n\n","category":"method"},{"location":"sparsegrids/#SparseGridsKit.integrate_on_sparsegrid-Tuple{Any, Any}","page":"Sparse Grids","title":"SparseGridsKit.integrate_on_sparsegrid","text":"integrate_on_sparsegrid(sg, f_on_grid, precomputed_lagrange_integrals)\n\nIntegrates a function (f_on_grid) over a sparse grid (sg) using precomputed Lagrange integrals.\n\nArguments\n\nsg: The sparse grid for integration.\nf_on_grid: A vector of function values on the sparse grid.\n\nReturns\n\nThe integral of the function over the sparse grid.\n\n\n\n\n\n","category":"method"},{"location":"sparsegrids/#SparseGridsKit.interpolate_on_sparsegrid-Tuple{Any, Any, Any}","page":"Sparse Grids","title":"SparseGridsKit.interpolate_on_sparsegrid","text":"interpolate_on_sparsegrid(sg, f_on_grid, target_points)\n\nInterpolates a function (f_on_grid) defined on a sparse grid (sg) to a set of target points.\n\nArguments\n\nsg: The source sparse grid.\nf_on_grid: A vector of function values on the sparse grid.\ntarget_points: A vector of target points for interpolation.\n\nReturns\n\nA vector of interpolated values at the target points.\n\n\n\n\n\n","category":"method"},{"location":"sparsegrids/#SparseGridsKit.interpolate_on_sparsegrid-Tuple{SparseGridApproximation, Any}","page":"Sparse Grids","title":"SparseGridsKit.interpolate_on_sparsegrid","text":"interpolate_on_sparsegrid(sga::SparseGridApproximation, target_points)\n\nInterpolates a SparseGridApproximation to a set of target points.\n\nArguments\n\nsga: SparseGridApproximation.\ntarget_points: A vector of target points for interpolation.\n\nReturns\n\nA vector of interpolated values at the target points.\n\n\n\n\n\n","category":"method"},{"location":"sparsegrids/#SparseGridsKit.map_from_to-Tuple{Any, Any}","page":"Sparse Grids","title":"SparseGridsKit.map_from_to","text":"map_from_to(sg_from, sg_to)\n\nMaps data from one sparse grid (sg_from) to another (sg_to).\n\nArguments\n\nsg_from: The source sparse grid.\nsg_to: The target sparse grid.\n\nReturns\n\nA vector that maps data from sg_from to sg_to.\n\n\n\n\n\n","category":"method"},{"location":"sparsegrids/#SparseGridsKit.precompute_lagrange_integrals","page":"Sparse Grids","title":"SparseGridsKit.precompute_lagrange_integrals","text":"precompute_lagrange_integrals(max_mi)\n\nPrecomputes the product integrals for Lagrange basis functions up to a given maximum multi-index (max_mi).\n\nArguments\n\nmax_mi: The maximum multi-index for which to precompute integrals.\n\nReturns\n\nA vector of precomputed product integrals for the Lagrange basis.\n\n\n\n\n\n","category":"function"},{"location":"sparsegrids/#SparseGridsKit.precompute_pairwise_norms-Tuple{Any}","page":"Sparse Grids","title":"SparseGridsKit.precompute_pairwise_norms","text":"precompute_pairwise_norms(f_on_grid, product)\n\nPrecomputes pairwise norms for function values (f_on_grid) using a specified product function.\n\nArguments\n\nf_on_grid: A vector of function values on the sparse grid.\nproduct: A function to compute the product between pairs of function values.\n\nReturns\n\nA matrix of pairwise norms.\n\n\n\n\n\n","category":"method"},{"location":"sparsegridinterpolation/#Sparse-Grid-Interpolation","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"","category":"section"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"Once a sparse grid is constructed, a polynomial approximation is formed by pairing the grid points with function evaluations.","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"If the multi-index set is admissible, and the sequences of sets of points are nested this approximation is an interpolating polynomial.","category":"page"},{"location":"sparsegridinterpolation/#One-dimensional-interpolation","page":"Sparse Grid Interpolation","title":"One-dimensional interpolation","text":"","category":"section"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"Consider a simple example approximating the function f-11tomathbbR","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"f(x) = 3x^2 + 2x + 1","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"Ths is expressed as the function f.","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"f(x) = [@. 3.0 * x[1]^2 + 2.0 * x[1] + 1.0]","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"Notice that the function f returns a one element Vector. This is not essential, but is advisable as vectors and scalars are treated differently in julia.","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"We can construct a one point approximation (i.e. constant polynomial). The function f is evaluated on the grid points accessed via get_grid_points.","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"n, k = 1, 0\nusing SparseGridsKit, LinearAlgebra\nmi_set = create_smolyak_miset(n, k)\nsg = create_sparsegrid(mi_set)\nf_on_grid = [f(x) for x in get_grid_points(sg)]","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"The sparse grid sg is paired with the point evaluations to interpolate on to target points. Notice that whilst we are in one-dimension, target_points is still a Vector of Vectors","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"target_points = [[x] for x in -1.0:0.5:1.0]\ninterpolation_result = interpolate_on_sparsegrid(sg, f_on_grid, target_points)","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"The constant approximation is fapprox 1. It is clear a better approximation can be formed. This is attained with a higher degree polynomial approximation – derived from a larger multi-index set.","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"mi_set_new = create_smolyak_miset(n, 1)\nsg_new = create_sparsegrid(mi_set_new)\nf_on_grid_new = [f(x) for x in get_grid_points(sg_new)]\n\ninterpolation_result_new = interpolate_on_sparsegrid(sg_new, f_on_grid_new, target_points)\n\nnorm([interpolation_result_new[i] - f(target_points[i]) for i in eachindex(target_points)]) < 1e-5","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"The number of grid points can be checked using get_n_grid_points and is seen to equal three. It is therefore no surprise that the approximation error is at machine precision - we can exactly represent the function f as a three point interpolant.","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"get_n_grid_points(sg_new) == 3","category":"page"},{"location":"sparsegridinterpolation/#Multi-dimensional-interpolation","page":"Sparse Grid Interpolation","title":"Multi-dimensional interpolation","text":"","category":"section"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"These ideas extend to vector valued functions with multi-dimensional domains. Consider a function","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"f-11^4 to mathbbR^400","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"defined via the gaussianpeak Genz test function (see e.g. [2]). A polynomial approximation can again be formed using nested Clenshaw-Curtis points and Smolyak multi-index sets.","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"using SparseGridsKit, LinearAlgebra, Plots, LaTeXStrings\nn, k = 4, 3\nmi_set = create_smolyak_miset(n, k)\nsg = create_sparsegrid(mi_set)\n\n# Define a complicated function\nnparams=100\nf(x) = [genz(n, 1.0, w, \"quadraticdecay\", \"gaussianpeak\")(x) for (i,w) = enumerate(range(-1,stop=1,length=nparams))]\nf_on_grid = [f(x) for x in get_grid_points(sg)]\n\nxplot = range(-1,stop=1,length=100)\nplot(xplot, [f([xi, zeros(3)...])[1] for xi in xplot],label=L\"f_{1}(x)\")\nplot!(xplot, [f([xi, zeros(3)...])[25] for xi in xplot],label=L\"f_{25}(x)\")\nplot!(xplot, [f([xi, zeros(3)...])[50] for xi in xplot],label=L\"f_{50}(x)\")\nplot!(xplot, [f([xi, zeros(3)...])[100] for xi in xplot],label=L\"f_{100}(x)\")\nplot!(\n    title=L\"f(x_1,0,0,...)\",\n    xlabel=L\"x_1\"\n)","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"This sparse grid approximation is constructed and evaluated at 100 test points. The norm of the error vector is computed and is small, but certainly not at machine precision.","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"nmc = Integer(1e2);\nV = [2 * rand(n) .- 1 for ii = 1:nmc]\nf_on_v = [interpolate_on_sparsegrid(sg, f_on_grid, [v])[1] for v in V]\nnorm([f_on_v[i] - f(V[i]) for i in eachindex(V)])","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"If we add multi-indices to the multi-index set we should have a better, higher degree polynomial approximation. The function f is analytic so we expect the polynomial approximation to converge quickly.","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"n, k = 4, 6\nmi_set = create_smolyak_miset(n, k)\nsg = create_sparsegrid(mi_set)\nf_on_grid = [f(x) for x in get_grid_points(sg)]\nf_on_v = interpolate_on_sparsegrid(sg, f_on_grid, V)\nnorm([f_on_v[i] - f(V[i]) for i in eachindex(V)])","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"n, k = 4, 7\nmi_set = create_smolyak_miset(n, k)\nsg = create_sparsegrid(mi_set)\nf_on_grid = [f(x) for x in get_grid_points(sg)]\nf_on_v = interpolate_on_sparsegrid(sg, f_on_grid, V)\nnorm([f_on_v[i] - f(V[i]) for i in eachindex(V)]) < 1e-5","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"Later, the function adaptive_sparsegrid will consider a greedy construction of the multi-index set to reduce the approximation error.","category":"page"},{"location":"sparsegridinterpolation/#Function-Reference","page":"Sparse Grid Interpolation","title":"Function Reference","text":"","category":"section"},{"location":"sparsegridinterpolation/#SparseGridsKit.interpolate_on_sparsegrid","page":"Sparse Grid Interpolation","title":"SparseGridsKit.interpolate_on_sparsegrid","text":"interpolate_on_sparsegrid(sg, f_on_grid, target_points)\n\nInterpolates a function (f_on_grid) defined on a sparse grid (sg) to a set of target points.\n\nArguments\n\nsg: The source sparse grid.\nf_on_grid: A vector of function values on the sparse grid.\ntarget_points: A vector of target points for interpolation.\n\nReturns\n\nA vector of interpolated values at the target points.\n\n\n\n\n\ninterpolate_on_sparsegrid(sga::SparseGridApproximation, target_points)\n\nInterpolates a SparseGridApproximation to a set of target points.\n\nArguments\n\nsga: SparseGridApproximation.\ntarget_points: A vector of target points for interpolation.\n\nReturns\n\nA vector of interpolated values at the target points.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Public-API-Reference","page":"SparseGridsKit.jl Public API Reference","title":"Public API Reference","text":"","category":"section"},{"location":"reference/","page":"SparseGridsKit.jl Public API Reference","title":"SparseGridsKit.jl Public API Reference","text":"","category":"page"},{"location":"reference/#Helper-Functions","page":"SparseGridsKit.jl Public API Reference","title":"Helper Functions","text":"","category":"section"},{"location":"reference/#SparseGridsKit.genz-Tuple{Int64, Float64, Float64, String, String}","page":"SparseGridsKit.jl Public API Reference","title":"SparseGridsKit.genz","text":"Generates the Genz test functions.\n\nArguments\n\nn::Int: Number of dimensions (positive integer).\nC::Float64: Scaling coefficient.\nW::Float64: Shift parameter.\nT::String: Decay type, options are \"nodecay\", \"quadraticdecay\", \"quarticdecay\", \"exponentialdecay\", and \"squaredexponentialdecay\".\nN::String: Function type, options are \"oscillatory\", \"productpeak\", \"productpeaknormalised\", \"cornerpeak\", \"gaussianpeak\", \"c0continuous\", and \"discontinuous\".\n\nReturns\n\nA function of specified Genz test function.\n\n\n\n\n\n","category":"method"},{"location":"functioninterpolation/#Sparse-Grids-for-More-General-Objects","page":"Interpolation of PDE solutions","title":"Sparse Grids for More General Objects","text":"","category":"section"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"More general objects can be interpolated and integrated via SparseGridsKit.jl. The SparseGridsKit supports objects for which addition is defined. For example, we can could consider ApproxFun objects or even Python objects provided they support addition.","category":"page"},{"location":"functioninterpolation/#Example:-ApproxFun.jl","page":"Interpolation of PDE solutions","title":"Example: ApproxFun.jl","text":"","category":"section"},{"location":"functioninterpolation/#One-Dimensional-Functions","page":"Interpolation of PDE solutions","title":"One Dimensional Functions","text":"","category":"section"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"We can consider interpolation of Fun objects. First a parametric Fun object can be evaluated at sparse grid points.","category":"page"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"using SparseGridsKit, ApproxFun, Plots, LaTeXStrings\nn, k = 1, 1\nmi_set = create_smolyak_miset(n, k)\nsg = create_sparsegrid(mi_set)\nf = y-> Fun(Taylor(),[y,2,3])\nf_on_grid = [f(x[1]) for x in get_grid_points(sg)]","category":"page"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"The Fun objects can then be interpolated using the interpolate_on_sparsegrid function. The interpolated Fun objects are plotted below.","category":"page"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"target_points = [[x] for x in -1.0:0.2:1.0]\ninterpolation_result = interpolate_on_sparsegrid(sg, f_on_grid, target_points)\nplot(interpolation_result,\n    xlims = (-2,2),\n)","category":"page"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"A challenge for some non-vector objects is intermediate scalar multiplications introduces additional allocations.","category":"page"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"@time interpolate_on_sparsegrid(sg, f_on_grid, target_points)","category":"page"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"Integration is also possible using the sparse grid formulation.","category":"page"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"expectedvalue = integrate_on_sparsegrid(sg,f_on_grid)","category":"page"},{"location":"functioninterpolation/#Two-dimensional-Elliptic-PDE","page":"Interpolation of PDE solutions","title":"Two dimensional Elliptic PDE","text":"","category":"section"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"The ApproxFun package offers a fast way to solve a model elliptic PDE. Given that the Fun objects can be used naturally within the SparseGridsKit.jl, we can consider computing an approximation to the solution of a parameteric elliptic PDE.","category":"page"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"This is set up on a two dimensional spatial domain D=-11^2.","category":"page"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"d = ChebyshevInterval()^2","category":"page"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"A parametric forcing function is defined with a parameter domain Gamma=-11^2.","category":"page"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"x,y = Fun(d)\n# Forcing is parametric\nf = z -> ProductFun((x,y)->exp.(-(1.01+z[1])*(x+0.3)^2-2(y-z[2])^2))","category":"page"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"The forced elliptic PDE","category":"page"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"-nabla u(xz) = f(xz) text for all  x in D u(xz) = 0 text for all  x in partial D","category":"page"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"is easily solved pointwise for any parameter z in Gamma.","category":"page"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"A = [Dirichlet(d); -Laplacian()]\n# Sln is parametric\nu = z -> ProductFun(\\(A, [zeros(∂(d)); f(z)]; tolerance=1E-6),d)\n\nz = [0, 0]\nuz = u(z)\nplot(uz)\nplot!(xlabel=L\"x_1\",\n        ylabel=L\"x_2\",\n        zlabel=L\"u(x,z)\")","category":"page"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"A sparse grid approximation can be constructed. The pointwise solutions on the sparse grid can be interpolated to give an approximation at any point in the domain. The animation below illustrates the changing sparse grid approximation and the approximation error for parameters on the circle Vert x Vert_2 = 1.","category":"page"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"n, k = 2,2\nmi_set = create_smolyak_miset(n, k)\nsg = create_sparsegrid(mi_set)\nf_on_grid = [u(z) for z in get_grid_points(sg)]\n\nnsteps = 100\npoints = get_grid_points(sg)\nx = [p[1] for p in points]\ny = [p[2] for p in points]\n@gif for i in range(0, stop = 2π, length = nsteps)\n        z = [cos(i),sin(i)]\n        interpolation_result = interpolate_on_sparsegrid(sg, f_on_grid, [z])\n\n        p1 = plot(interpolation_result[1])\n        plot!(zlims!(0,0.3),title=\"SG Approximation\")\n        plot!(xlabel=L\"x_1\",\n        ylabel=L\"x_2\",\n        zlabel=L\"u(x,z)\")\n\n        p2 = plot(interpolation_result[1]-u(z))\n        plot!(zlims!(-3e-2,3e-2),title=\"Interpolation Error\")\n        plot!(xlabel=L\"x_1\",\n        ylabel=L\"x_2\",\n        zlabel=L\"e(x,z)\")\n\n        p3 = scatter(x,y,label=\"grid\")\n        scatter!(p3, [z[1]],[z[2]],label=\"z\")\n        plot(p1, p2, p3, layout=[2,2])\n        plot!(xlabel=L\"y_1\",\n        ylabel=L\"y_2\")\nend","category":"page"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"The sparse grid has been constructed using Clenshaw–Curtis points. The quadrature rules can be applied assuming an underlying weight function rho(y)=05^2. If this is interpreted as a probabiliy then integration gives the expected value of the PDE solution.","category":"page"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"expectedvalue = ProductFun(integrate_on_sparsegrid(sg,f_on_grid),d)\nplot(expectedvalue)\nplot!(title=\"Approximation of Expected Value\",\n        xlabel=L\"x_1\",\n        ylabel=L\"x_2\",\n        zlabel=L\"\\mathbb{E}[u(x,\\cdot)]\")","category":"page"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"Similarly an approximation of the variance can be computed and interpolated.","category":"page"},{"location":"functioninterpolation/","page":"Interpolation of PDE solutions","title":"Interpolation of PDE solutions","text":"square = PF -> ProductFun(PF*PF,d)\nvariance = ProductFun(integrate_on_sparsegrid(sg,[square(f_on_grid[i]-expectedvalue) for i in eachindex(f_on_grid)]),d)\nplot(variance)\nplot!(title=\"Approximation of Variance\",\n        xlabel=L\"x_1\",\n        ylabel=L\"x_2\",\n        zlabel=L\"Var[u(x,\\cdot)]\")","category":"page"},{"location":"misets/#Multi-Index-Sets","page":"Multi-Index Sets","title":"Multi Index Sets","text":"","category":"section"},{"location":"misets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"Sparse grids are constructed via multi-index sets specifying a cleverly chosen linear combination of tensor product grids.","category":"page"},{"location":"misets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"Suppose we consider a function u with domain GammainmathbbR^n.","category":"page"},{"location":"misets/#Tensor-Product-Multi-Index-Sets","page":"Multi-Index Sets","title":"Tensor Product Multi-Index Sets","text":"","category":"section"},{"location":"misets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"The multi-index set","category":"page"},{"location":"misets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"alpha  Vert alpha Vert_infty leq n + d subset N^d","category":"page"},{"location":"misets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"is constructed using the create_tensor_miset function.","category":"page"},{"location":"misets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"using SparseGridsKit\n\nn, k = 2, 1\nmi_set = create_tensor_miset(n, k)","category":"page"},{"location":"misets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"The multi-index set can be viewed a vector of Vector{Integer} representing each multi-index:","category":"page"},{"location":"misets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"get_mi(mi_set)","category":"page"},{"location":"misets/#Smolyak-Multi-Index-Sets","page":"Multi-Index Sets","title":"Smolyak Multi-Index Sets","text":"","category":"section"},{"location":"misets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"The standard Smolyak construction are also easily constructed. The multi-index set","category":"page"},{"location":"misets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"alpha  Vert alpha Vert_1 leq n + d subset N^2","category":"page"},{"location":"misets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"is constructed using the following syntax.","category":"page"},{"location":"misets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"using SparseGridsKit\n\nn, k = 2, 1\nmi_set = create_smolyak_miset(n, k)","category":"page"},{"location":"misets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"This gives a different, smaller multi-index set than the tensor product multi-index set.","category":"page"},{"location":"misets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"get_mi(mi_set)","category":"page"},{"location":"misets/#Manipulating-Multi-Index-Sets","page":"Multi-Index Sets","title":"Manipulating Multi-Index Sets","text":"","category":"section"},{"location":"misets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"The multi-index set can be altered by adding additional multi-indices. Continuing using the above Smolyak example, we add the multi-index 1 3 with the add_mi function.","category":"page"},{"location":"misets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"mi_set_new = MISet([[1,3]]) \ncombined_mi_set = add_mi(mi_set, mi_set_new)","category":"page"},{"location":"misets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"In Gerstner–Griebel style adaptive algorithms, the margin and reduced margin are generally required. These are easily computed using the get_margin and get_reduced_margin functions.","category":"page"},{"location":"misets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"margin_set = get_margin(combined_mi_set)","category":"page"},{"location":"misets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"reduced_margin_set = get_reduced_margin(combined_mi_set)","category":"page"},{"location":"misets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"Notice how the multi-index 23 is in the margin but not the reduced margin. Its backwards neighbour 22 is missing from combined_mi_set.","category":"page"},{"location":"misets/#Function-Reference","page":"Multi-Index Sets","title":"Function Reference","text":"","category":"section"},{"location":"misets/#SparseGridsKit.add_mi-Tuple{MISet, MISet}","page":"Multi-Index Sets","title":"SparseGridsKit.add_mi","text":"add_mi(mi_set, mi_set_new)\n\nAdds a new set of multi-indices (mi_set_new) to an existing multi-index set (mi_set).\n\nArguments\n\nmi_set: The original multi-index set.\nmi_set_new: A new MISet to be added to the original.\n\nReturns\n\nA new MISet containing the combined and sorted multi-indices.\n\n\n\n\n\n","category":"method"},{"location":"misets/#SparseGridsKit.add_mi-Tuple{MISet, Vector{Int64}}","page":"Multi-Index Sets","title":"SparseGridsKit.add_mi","text":"add_mi(mi_set, mi_new)\n\nAdds a single new multi-index (mi_new) to an existing multi-index set (mi_set).\n\nArguments\n\nmi_set: The original multi-index set.\nmi_new: A new multi-index vector to be added.\n\nReturns\n\nA new MISet containing the updated and sorted multi-indices.\n\n\n\n\n\n","category":"method"},{"location":"misets/#SparseGridsKit.check_admissibility-Tuple{MISet}","page":"Multi-Index Sets","title":"SparseGridsKit.check_admissibility","text":"check_admissibility(miset)\n\nChecks the admissibility of a multi-index set miset.\n\nArguments\n\nmiset: An instance of MISet.\n\nReturns\n\nadmissibile: True or false\nmi_missing: Missing multi-indices\n\n\n\n\n\n","category":"method"},{"location":"misets/#SparseGridsKit.check_index_admissibility-Tuple{MISet, Any}","page":"Multi-Index Sets","title":"SparseGridsKit.check_index_admissibility","text":"check_index_admissibility(miset, mi)\n\nChecks the admissibility of a single multi-index mi in a multi-index set miset.\n\nArguments\n\nmiset: Multi-index set.\nmi: Multi-index to check or vector of multi-indices to check.\n\nReturns\n\nadmissibile: True or false\nmi_missing: Missing multi-indices\n\n\n\n\n\n","category":"method"},{"location":"misets/#SparseGridsKit.create_box_miset-Tuple{Any, Any}","page":"Multi-Index Sets","title":"SparseGridsKit.create_box_miset","text":"create_box_miset(n, k)\n\nCreates a rectangular multi-index set for a given dimension (n) and levels vector (k).\n\nArguments\n\nn: The dimensionality of the space.\nk: A vector of levels for each dimension.\n\n\n\n\n\n","category":"method"},{"location":"misets/#SparseGridsKit.create_rule_miset-Tuple{Any, Any, Any}","page":"Multi-Index Sets","title":"SparseGridsKit.create_rule_miset","text":"create_rule_miset(n, k, rule)\n\nCreates a multi-index set for a given dimension (n) and with rule(mi) less than or equal to k.\n\nArguments\n\nn: The dimensionality of the space.\nk: Maximum for rule(mi)\nrule: Rule to compute on each MI\n\n\n\n\n\n","category":"method"},{"location":"misets/#SparseGridsKit.create_smolyak_miset-Tuple{Any, Any}","page":"Multi-Index Sets","title":"SparseGridsKit.create_smolyak_miset","text":"create_smolyak_miset(n, k)\n\nCreates a Smolyak multi-index set for a given dimension (n) and level (k).\n\nArguments\n\nn: The dimensionality of the space.\nk: The level of the Smolyak grid.\n\nReturns\n\nAn MISet representing the Smolyak multi-index set.\n\n\n\n\n\n","category":"method"},{"location":"misets/#SparseGridsKit.create_tensor_miset-Tuple{Any, Any}","page":"Multi-Index Sets","title":"SparseGridsKit.create_tensor_miset","text":"create_tensor_miset(n, k)\n\nCreates a tensor product multi-index set for a given dimension (n) and level (k).\n\nArguments\n\nn: The dimensionality of the space.\nk: The level of the tensor product grid.\n\nReturns\n\nAn MISet representing the tensor product multi-index set.\n\n\n\n\n\n","category":"method"},{"location":"misets/#SparseGridsKit.create_totaldegree_miset-Tuple{Any, Any}","page":"Multi-Index Sets","title":"SparseGridsKit.create_totaldegree_miset","text":"create_totaldegree_miset(n, k)\n\nCreates a multi-index set for a given dimension (n) and with total levels less than or equal to k.\n\nArguments\n\nn: The dimensionality of the space.\nk: Total degree\n\n\n\n\n\n","category":"method"},{"location":"misets/#SparseGridsKit.get_margin-Tuple{MISet}","page":"Multi-Index Sets","title":"SparseGridsKit.get_margin","text":"get_margin(mi_set)\n\nCalculates the margin of a multi-index set (mi_set), which is the set of multi-indices that can extend the current set.\n\nArguments\n\nmi_set: An instance of MISet.\n\nReturns\n\nAn MISet containing the margin set.\n\n\n\n\n\n","category":"method"},{"location":"misets/#SparseGridsKit.get_mi-Tuple{MISet}","page":"Multi-Index Sets","title":"SparseGridsKit.get_mi","text":"get_mi(mi_set)\n\nRetrieves the list of multi-indices from a given MISet.\n\nArguments\n\nmi_set: An instance of MISet.\n\nReturns\n\nA vector of multi-index vectors.\n\n\n\n\n\n","category":"method"},{"location":"misets/#SparseGridsKit.get_n_mi-Tuple{MISet}","page":"Multi-Index Sets","title":"SparseGridsKit.get_n_mi","text":"get_n_mi(mi_set)\n\nReturns the number of multi-indices in a given MISet.\n\nArguments\n\nmi_set: An instance of MISet.\n\nReturns\n\nThe number of multi-indices in the set.\n\n\n\n\n\n","category":"method"},{"location":"misets/#SparseGridsKit.get_reduced_margin-Tuple{MISet}","page":"Multi-Index Sets","title":"SparseGridsKit.get_reduced_margin","text":"get_reduced_margin(mi_set)\n\nCalculates the reduced margin of a multi-index set (mi_set), which removes indices already in the set.\n\nArguments\n\nmi_set: An instance of MISet.\n\nReturns\n\nAn MISet containing the reduced margin set.\n\n\n\n\n\n","category":"method"},{"location":"#SparseGridsKit.jl","page":"SparseGridsKit.jl","title":"SparseGridsKit.jl","text":"","category":"section"},{"location":"","page":"SparseGridsKit.jl","title":"SparseGridsKit.jl","text":"A simple implementation of sparse grid polynomial interpolation and corresponding interpolation.","category":"page"},{"location":"","page":"SparseGridsKit.jl","title":"SparseGridsKit.jl","text":"To add the package use the following command:","category":"page"},{"location":"","page":"SparseGridsKit.jl","title":"SparseGridsKit.jl","text":"] add https://github.com/benmkent/SparseGridsKit.jl","category":"page"},{"location":"","page":"SparseGridsKit.jl","title":"SparseGridsKit.jl","text":"The construction is based upon the sparse operators introduced by Smolyak [1]. Key papers defining the model formulation include [2], [3] and [4]. This construction of the approximation is inspired by the Sparse Grids MATLAB Kit [5].","category":"page"},{"location":"","page":"SparseGridsKit.jl","title":"SparseGridsKit.jl","text":"This documentation is example driven, with full documentation for each subset of functions given at the end of the relevant example. This is not a thorough mathematical description of sparse grid approximation, but a practical guide to using the software.","category":"page"},{"location":"","page":"SparseGridsKit.jl","title":"SparseGridsKit.jl","text":"The package is still under development and by no means complete.","category":"page"},{"location":"","page":"SparseGridsKit.jl","title":"SparseGridsKit.jl","text":"An example sparse grid construction is illustrated below. ","category":"page"},{"location":"","page":"SparseGridsKit.jl","title":"SparseGridsKit.jl","text":"using SparseGridsKit, Plots, LaTeXStrings\n# Test create_sparsegrid\nn,k =3,3\nknots = [CCPoints(), CCPoints(), UniformPoints()]\nrules = [Doubling(), Doubling(), Linear()]\nmi_set = create_smolyak_miset(n,k)\nsg = create_sparsegrid(mi_set, knots=knots, rule=rules)\nnsteps = 100\n@gif for i in range(0, stop = 2π, length = nsteps)\n        plot(sg)\n        plot!(\n                title=\"Sparse Grid n,k=\"*string(n)*\",\"*string(k),\n                xlabel=L\"y_1\",\n                ylabel=L\"y_2\",\n                zlabel=L\"y_3\",\n                camera = (20 * (1 + cos(i)),10 * (1 + cos(i)))\n                )\nend","category":"page"},{"location":"adaptivesparsegrids/#Adaptive-Sparse-Grids","page":"Adaptive Sparse Grids","title":"Adaptive Sparse Grids","text":"","category":"section"},{"location":"adaptivesparsegrids/","page":"Adaptive Sparse Grids","title":"Adaptive Sparse Grids","text":"Sparse grids can be adaptively constructed using a Gerstner–Griebel [4] type construction. This is implemented in the adaptive_sparsegrid function.","category":"page"},{"location":"adaptivesparsegrids/#One-dimensional-example","page":"Adaptive Sparse Grids","title":"One dimensional example","text":"","category":"section"},{"location":"adaptivesparsegrids/","page":"Adaptive Sparse Grids","title":"Adaptive Sparse Grids","text":"To illustrate the adaptive algorithm consider functions that can be exactly approximated using a sparse grid approximation. Consider the polynomial f-11mapstoR","category":"page"},{"location":"adaptivesparsegrids/","page":"Adaptive Sparse Grids","title":"Adaptive Sparse Grids","text":"f(x) = 3x^2 + 2x +1","category":"page"},{"location":"adaptivesparsegrids/","page":"Adaptive Sparse Grids","title":"Adaptive Sparse Grids","text":"using SparseGridsKit\nnparams = 1\nf(x) = @. 3.0*x[1]^2 + 2.0*x[1] + 1.0","category":"page"},{"location":"adaptivesparsegrids/","page":"Adaptive Sparse Grids","title":"Adaptive Sparse Grids","text":"The adaptive_sparsegrid function can be called with a function f and the dimension of the function domain nparams.","category":"page"},{"location":"adaptivesparsegrids/","page":"Adaptive Sparse Grids","title":"Adaptive Sparse Grids","text":"(sg, f_on_Z) = adaptive_sparsegrid(f, nparams)","category":"page"},{"location":"adaptivesparsegrids/","page":"Adaptive Sparse Grids","title":"Adaptive Sparse Grids","text":"The function f can be exactly represented by a three point interpolant, which is identified in the adaptive algorithm.","category":"page"},{"location":"adaptivesparsegrids/","page":"Adaptive Sparse Grids","title":"Adaptive Sparse Grids","text":"test_points = range(-1,stop=1,length=100)\nall([f(x)] ≈ interpolate_on_sparsegrid(sg,f_on_Z,x) for x in test_points),  get_n_grid_points(sg) == 3","category":"page"},{"location":"adaptivesparsegrids/","page":"Adaptive Sparse Grids","title":"Adaptive Sparse Grids","text":"Taking powers k of the polynomial f gives a polynomial f^k of polynomial degree 2^k. Consequently, this is represented exactly using 2^k+1 interpolation points. The adaptive algorithm identifies this.","category":"page"},{"location":"adaptivesparsegrids/","page":"Adaptive Sparse Grids","title":"Adaptive Sparse Grids","text":"f2(x) = f(x).^2\n(sg, f2_on_Z) = adaptive_sparsegrid(f2, nparams)\n# Expect three point approx cubic (1 iteration to suffice)\nall([f2(x)] ≈ interpolate_on_sparsegrid(sg,f2_on_Z,x) for x in test_points), \nget_n_grid_points(sg) == 5","category":"page"},{"location":"adaptivesparsegrids/","page":"Adaptive Sparse Grids","title":"Adaptive Sparse Grids","text":"f3(x) = f(x).^3\n(sg, f3_on_Z) = adaptive_sparsegrid(f3, nparams)\n# Expect three point approx cubic (1 iteration to suffice)\nall([f3(x)] ≈ interpolate_on_sparsegrid(sg,f3_on_Z,x) for x in test_points)\nget_n_grid_points(sg)","category":"page"},{"location":"adaptivesparsegrids/#Multi-dimensional-example","page":"Adaptive Sparse Grids","title":"Multi-dimensional example","text":"","category":"section"},{"location":"adaptivesparsegrids/","page":"Adaptive Sparse Grids","title":"Adaptive Sparse Grids","text":"The adaptive algorithm is also applicable for higher dimensional functions. Consider the genz gaussianpeak example.","category":"page"},{"location":"adaptivesparsegrids/","page":"Adaptive Sparse Grids","title":"Adaptive Sparse Grids","text":"using SparseGridsKit, LinearAlgebra\nn = 8\nC = 1.0\nW = 0.0\nT = \"exponentialdecay\"\nN = \"gaussianpeak\"\nf = genz(n::Int, C::Float64, W::Float64, T::String, N::String)","category":"page"},{"location":"adaptivesparsegrids/","page":"Adaptive Sparse Grids","title":"Adaptive Sparse Grids","text":"An adaptive approximation is formed. This produces a (relatively) accurate approximation of the high-dimensional function f. The iterations halt when the stopping criterion of max profit p_max < proftol.","category":"page"},{"location":"adaptivesparsegrids/","page":"Adaptive Sparse Grids","title":"Adaptive Sparse Grids","text":"# Approximate\n(sg, f_on_Z) = adaptive_sparsegrid(f, n)\n\nnmc = 100\ntest_points = [2 * rand(8) .- 1 for ii = 1:nmc]\n\nf_approx_on_test = interpolate_on_sparsegrid(sg,f_on_Z,test_points)\n\nnorm([f(x) - f_approx_on_test[i] for (i,x) in enumerate(test_points)])","category":"page"},{"location":"adaptivesparsegrids/","page":"Adaptive Sparse Grids","title":"Adaptive Sparse Grids","text":"Reducing proftol allows further iterations and a more accurate approximation.","category":"page"},{"location":"adaptivesparsegrids/","page":"Adaptive Sparse Grids","title":"Adaptive Sparse Grids","text":"(sg, f_on_Z) = adaptive_sparsegrid(f, n, proftol=1e-5)\n\nf_approx_on_test = interpolate_on_sparsegrid(sg,f_on_Z,test_points)\n\nnorm([f(x) - f_approx_on_test[i] for (i,x) in enumerate(test_points)])","category":"page"},{"location":"adaptivesparsegrids/#Functions","page":"Adaptive Sparse Grids","title":"Functions","text":"","category":"section"},{"location":"adaptivesparsegrids/#SparseGridsKit.EvaluationDictionary","page":"Adaptive Sparse Grids","title":"SparseGridsKit.EvaluationDictionary","text":"evaluations_database\n\n\n\n\n\n","category":"type"},{"location":"adaptivesparsegrids/#SparseGridsKit.EvaluationDictionary-Tuple{Any, Any}","page":"Adaptive Sparse Grids","title":"SparseGridsKit.EvaluationDictionary","text":"EvaluationDictionary(sg,f_on_z)\n\nCreates an EvaluationDictionary from a sparse grid and function evaluations\n\nArguments\n\nsg: Sparse grid\nf_on_z: Function evaluations on the sparse grid\n\nReturns\n\nevaluations: EvaluationDictionary\n\n\n\n\n\n","category":"method"},{"location":"adaptivesparsegrids/#SparseGridsKit.EvaluationDictionary-Union{Tuple{}, Tuple{T}} where T","page":"Adaptive Sparse Grids","title":"SparseGridsKit.EvaluationDictionary","text":"EvaluationDictionary()\n\nCreates an empty EvaluationDictionary\n\nReturns\n\nevaluations: EvaluationDictionary\n\n\n\n\n\n","category":"method"},{"location":"adaptivesparsegrids/#SparseGridsKit.adaptive_estimate-NTuple{4, Any}","page":"Adaptive Sparse Grids","title":"SparseGridsKit.adaptive_estimate","text":"adaptive_estimate(sg, datastore, pcl, type=:deltaint)\n\nEstimates the profit of adding multi-indices {α} in reduced margin to the sparse grid.\n\nArguments\n\nsg: Sparse grid.\ndatastore: EvaluationDictionary.\nrule: Level function(s) for sparse grid.\nknots: Knot function(s) for sparse grid.\ntype: Type of profit computation. Default is :deltaint.\n\nReturns\n\nVector of profits for each multi-index α.\n\n\n\n\n\n","category":"method"},{"location":"adaptivesparsegrids/#SparseGridsKit.adaptive_mark","page":"Adaptive Sparse Grids","title":"SparseGridsKit.adaptive_mark","text":"adaptive_mark(α, p_α, θ=1e-4)\n\nDorfler style marking of multi-indices based on profits\n\nArguments\n\nα: Multi-indices in reduced margin.\np_α: Vector of profits.\nθ: Threshold for marking. Default is 1e-4.\n\n\n\n\n\n","category":"function"},{"location":"adaptivesparsegrids/#SparseGridsKit.adaptive_refine-NTuple{5, Any}","page":"Adaptive Sparse Grids","title":"SparseGridsKit.adaptive_refine","text":"adaptive_refine(sg, α_marked, rule, knots)\n\nRefines the sparse grid based on marked multi-indices\n\nArguments\n\nsg: Sparse grid.\nα_marked: Marked multi-indices.\nrule: Level function(s) for sparse grid.\nknots: Knot function(s) for sparse grid.\n\nReturns\n\nsg: Refined sparse grid.\nf_on_z: Function evaluations on the refined sparse grid.\n\n\n\n\n\n","category":"method"},{"location":"adaptivesparsegrids/#SparseGridsKit.adaptive_solve!-Tuple{Any, Any, Any}","page":"Adaptive Sparse Grids","title":"SparseGridsKit.adaptive_solve!","text":"adaptive_solve!(f, datastore, sg)\n\nAdds function evaluations on sg to datastore\n\nArguments\n\nf: Function\ndatastore: EvaluationDictionary\nsg: Sparse grid\n\nReturns\n\ndatastore: Updated EvaluationDictionary\n\n\n\n\n\n","category":"method"},{"location":"adaptivesparsegrids/#SparseGridsKit.adaptive_sparsegrid-Tuple{Any, Any}","page":"Adaptive Sparse Grids","title":"SparseGridsKit.adaptive_sparsegrid","text":"adaptive_sparsegrid(f, nparams; maxpts = 100, proftol = 1e-4, rule=Doubling(), knots=CCPoints(), θ=1e-4, type=:deltaint)\n\nConstructs an adaptive sparse grid for approximating the function f in nparams dimensions.\n\nArguments\n\nf: Function to be approximated taking arguments x with length(x)=nparams.\nnparams: Dimension of domain.\nmaxpts: (Optional) Maximum number of points to include in the sparse grid. Default is 100.\nproftol: (Optional) Tolerance for profits. Default is 1e-4.\nrule: (Optional) Level function(s) for sparse grid. Default is Doubling().\nknots: (Optional) Knot function(s) for sparse grid. Default is CCPoints().\nθ: (Optional) Threshold for marking. Default is 1e-4.\ntype: (Optional) Type of profit computation. Default is :deltaint.\ncostfunction (Optional) Cost function for fidelity related multi-indices.\n\nReturns\n\nsg: Final sparse grid used to approximate f\nf_on_z: Evaluations of f on grid points in sparse grid sg\n\n\n\n\n\n","category":"method"},{"location":"adaptivesparsegrids/#SparseGridsKit.adaptive_terminate-NTuple{4, Any}","page":"Adaptive Sparse Grids","title":"SparseGridsKit.adaptive_terminate","text":"adaptiveterminate(sg, pα, maxpts, proftol)\n\nTest profits and sparse grid to determine loop termination\n\nArguments\n\nsg: Sparse grid.\np_α: Vector of profits.\nmaxpts: Maximum number of grid points allowed.\nproftol: Profit tolerance.\n\nReturns\n\nFlag to indicate loop termination if maxpts has been reached, or proftol attained.\n\n\n\n\n\n","category":"method"},{"location":"adaptivesparsegrids/#SparseGridsKit.add_evaluation!-Tuple{Any, Any, Any}","page":"Adaptive Sparse Grids","title":"SparseGridsKit.add_evaluation!","text":"add_evaluation!(evaluations, z, f_at_z)\n\nAdds the evaluation fatz into the evaluations_database\n\nArguments\n\nevaluations: EvaluationDictionary\nz: Point\nf_at_z: Function evaluation at z\n\nReturns\n\nevaluations: Updated EvaluationDictionary\n\n\n\n\n\n","category":"method"},{"location":"adaptivesparsegrids/#SparseGridsKit.add_evaluations!-Tuple{Any, SparseGrid, Any}","page":"Adaptive Sparse Grids","title":"SparseGridsKit.add_evaluations!","text":"add_evaluations!(evaluations, sg::SparseGrid, f_on_z)\n\nAdds the evaluations fonz into the evaluations_database\n\nArguments\n\nevaluations: EvaluationDictionary\nsg: Sparse grid\nf_on_z: Function evaluations on the sparse grid\n\nReturns\n\nevaluations: Updated EvaluationDictionary\n\n\n\n\n\n","category":"method"},{"location":"adaptivesparsegrids/#SparseGridsKit.compute_profit-NTuple{5, Any}","page":"Adaptive Sparse Grids","title":"SparseGridsKit.compute_profit","text":"compute_profit(sg_α, f_α, f, cost, pcl; type=:deltaint)\n\nComputes the \"profit\" of a sparse grid supplemented by a multi-index α\n\nArguments\n\nsg_α: Enhanced sparse grid with α\nsg: Sparse grid\nf_α: Function evaluations at grid points in α\nf: Function evaluations on the sparse grid.\ncost: Cost of adding α to the sparse grid.\ntype: Type of profit computation. Default is :deltaint. Options are :deltaint, :deltaintcost, :Linf, :Linfcost.\n\nReturns\n\nComputed profit as Expected change in approximation.\n\n\n\n\n\n","category":"method"},{"location":"adaptivesparsegrids/#SparseGridsKit.retrieve_evaluations-Tuple{Any, Any}","page":"Adaptive Sparse Grids","title":"SparseGridsKit.retrieve_evaluations","text":"retrieve_evaluations(evaluations, sg)\n\nRetrieves the evaluations from the evaluations_database\n\nArguments\n\nevaluations: EvaluationDictionary\nsg: Sparse grid\n\nReturns\n\nf_on_z: Function evaluations on the sparse grid\n\n\n\n\n\n","category":"method"}]
}
