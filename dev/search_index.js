var documenterSearchIndex = {"docs":
[{"location":"sparsegridinterpolation/#Sparse-Grid-Interpolation","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"","category":"section"},{"location":"sparsegridinterpolation/#One-dimensional-interpolation","page":"Sparse Grid Interpolation","title":"One-dimensional interpolation","text":"","category":"section"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"Consider a simple example approximating a function f-11toR.","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"f(x) = [@. 3.0 * x[1]^2 + 2.0 * x[1] + 1.0]","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"We can construct a one point approximation (i.e. constant polynomial). The sparse grid is constructed using the MISet mi_set. The function f is evaluated on the grid points accessed via get_grid_points.","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"n, k = 1, 0\nusing SparseGridsKit, LinearAlgebra\nmi_set = create_smolyak_miset(n, k)\nsg = create_sparsegrid(mi_set)\nf_on_grid = [f(x) for x in get_grid_points(sg)]","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"The sparse grid sg is paired with the point evaluations to interpolate on to target points.","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"target_points = [[x] for x in -1.0:0.5:1.0]\ninterpolation_result = interpolate_on_sparsegrid(sg, f_on_grid, target_points)","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"It is clear a better approximation can be formed.","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"mi_set_new = create_smolyak_miset(n, 2)\nsg_new = create_sparsegrid(mi_set_new)\nf_on_grid_new = [f(x) for x in get_grid_points(sg_new)]\n\ninterpolation_result_new = interpolate_on_sparsegrid(sg_new, f_on_grid_new, target_points)\n\nnorm([interpolation_result_new[i] - f(target_points[i]) for i in eachindex(target_points)])","category":"page"},{"location":"sparsegridinterpolation/#Multi-dimensional-interpolation","page":"Sparse Grid Interpolation","title":"Multi-dimensional interpolation","text":"","category":"section"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"These ideas extend to multi-dimensional, vector valued functions. Consider a function f-11^4 to mathbbR400.","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"using SparseGridsKit, LinearAlgebra\nn, k = 4, 3\nmi_set = create_smolyak_miset(n, k)\nsg = create_sparsegrid(mi_set)\n# Define a complicated function\nndims=100\nf(x) = [genz(n, 1.0, w, \"quadraticdecay\", \"gaussianpeak\")(x) for (i,w) = enumerate(range(-1,stop=1,length=ndims))]\nf_on_grid = [f(x) for x in get_grid_points(sg)]","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"The sparse grid approximation defines a polynomial that can be evaluated.","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"nmc = Integer(1e2);\nV = [2 * rand(n) .- 1 for ii = 1:nmc]\nf_on_v = [interpolate_on_sparsegrid(sg, f_on_grid, [v])[1] for v in V]\nnorm([f_on_v[i] - f(V[i]) for i in eachindex(V)])","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"In this case this is poor. We consider approximating the polynomial approximation. If we grow the polynomial approximation space by adding multi-indices to the multi-index set we have a different polynomial approximation. Consider the enriched approximation space formed by the union with the reduced margin.","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"mi_enriched = add_mi(mi_set, get_reduced_margin(mi_set))\nsg_enriched = create_sparsegrid(mi_enriched)\ndisplay(get_n_grid_points(sg_enriched))","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"Interpolating the polynomial via this new sparse grid should give the same function.","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"f_on_grid_2 = interpolate_on_sparsegrid(sg, f_on_grid, get_grid_points(sg_enriched))\nf2_on_v = interpolate_on_sparsegrid(sg_enriched, f_on_grid_2, V)\nnorm([f_on_v[i] - f2_on_v[i] for i in eachindex(V)])","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"The function f is analytic so we expect the polynomial approximation to converge. The approximation can be improved by increasing the size of the approximation space, at greater computational cost.","category":"page"},{"location":"sparsegridinterpolation/","page":"Sparse Grid Interpolation","title":"Sparse Grid Interpolation","text":"n, k = 4, 6\nmi_set = create_smolyak_miset(n, k)\nsg = create_sparsegrid(mi_set)\nf_on_grid = [f(x) for x in get_grid_points(sg)]\nf_on_v = interpolate_on_sparsegrid(sg, f_on_grid, V)\nnorm([f_on_v[i] - f(V[i]) for i in eachindex(V)])","category":"page"},{"location":"multiindexsets/#Multi-Index-Sets","page":"Multi-Index Sets","title":"Multi Index Sets","text":"","category":"section"},{"location":"multiindexsets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"Multi-index sets the standard Smolyak construction are easily constructed. Suppose we consider a function u with domain GammainR^n. The multi-index set $ {\\alpha : \\Vert \\alpha \\Vert_1 \\leq n + d} \\subset \\N^{2} $ is constructed using the following syntax.","category":"page"},{"location":"multiindexsets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"using SparseGridsKit\n\nn, k = 2, 1\nmi_set = create_smolyak_miset(n, k)","category":"page"},{"location":"multiindexsets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"The multi-index set can be viewed a vector of Vector{Integer} representing each multi-index:","category":"page"},{"location":"multiindexsets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"get_mi(mi_set)","category":"page"},{"location":"multiindexsets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"The multi-index set can be altered by adding additional multi-indices.","category":"page"},{"location":"multiindexsets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"mi_set_new = MISet([[1,3]]) \ncombined_mi_set = add_mi(mi_set, mi_set_new)","category":"page"},{"location":"multiindexsets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"In Gerstner–Griebel style algorithms, the margin and reduced margin are often required. These are easily computed. For example the margin,","category":"page"},{"location":"multiindexsets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"margin_set = get_margin(combined_mi_set)","category":"page"},{"location":"multiindexsets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"and the reduced margin,","category":"page"},{"location":"multiindexsets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"reduced_margin_set = get_reduced_margin(combined_mi_set)","category":"page"},{"location":"multiindexsets/","page":"Multi-Index Sets","title":"Multi-Index Sets","text":"Notice how the multi-index 23 is in the margin but not the reduced margin. Its backwards neighbour 22 is missing from the multi-index set.","category":"page"},{"location":"reference/#Functions","page":"Reference","title":"Functions","text":"","category":"section"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#Functions-2","page":"Reference","title":"Functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [SparseGridsKit]","category":"page"},{"location":"reference/#SparseGridsKit.add_mi-Tuple{MISet, MISet}","page":"Reference","title":"SparseGridsKit.add_mi","text":"add_mi(mi_set, mi_set_new)\n\nAdds a new set of multi-indices (mi_set_new) to an existing multi-index set (mi_set).\n\nArguments\n\nmi_set: The original multi-index set.\nmi_set_new: A new MISet to be added to the original.\n\nReturns\n\nA new MISet containing the combined and sorted multi-indices.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseGridsKit.add_mi-Tuple{MISet, Vector}","page":"Reference","title":"SparseGridsKit.add_mi","text":"add_mi(mi_set, mi_new)\n\nAdds a single new multi-index (mi_new) to an existing multi-index set (mi_set).\n\nArguments\n\nmi_set: The original multi-index set.\nmi_new: A new multi-index vector to be added.\n\nReturns\n\nA new MISet containing the updated and sorted multi-indices.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseGridsKit.create_smolyak_miset-Tuple{Any, Any}","page":"Reference","title":"SparseGridsKit.create_smolyak_miset","text":"create_smolyak_miset(n, k)\n\nCreates a Smolyak multi-index set for a given dimension (n) and level (k).\n\nArguments\n\nn: The dimensionality of the space.\nk: The level of the Smolyak grid.\n\nReturns\n\nAn MISet representing the Smolyak multi-index set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseGridsKit.create_sparsegrid-Tuple{Any}","page":"Reference","title":"SparseGridsKit.create_sparsegrid","text":"create_sparsegrid(mi_set)\n\nCreates a sparse grid based on the provided multi-index set (mi_set).\n\nArguments\n\nmi_set: An instance of MISet containing the multi-index set for grid construction.\n\nReturns\n\nA sparse grid object constructed using the specified multi-index set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseGridsKit.genz-Tuple{Int64, Float64, Float64, String, String}","page":"Reference","title":"SparseGridsKit.genz","text":"Generates the Genz test functions.\n\nArguments\n\nn::Int: Number of dimensions (positive integer).\nC::Float64: Scaling coefficient.\nW::Float64: Shift parameter.\nT::String: Decay type, options are \"nodecay\", \"quadraticdecay\", \"quarticdecay\", \"exponentialdecay\", and \"squaredexponentialdecay\".\nN::String: Function type, options are \"oscillatory\", \"productpeak\", \"productpeaknormalised\", \"cornerpeak\", \"gaussianpeak\", \"c0continuous\", and \"discontinuous\".\n\nReturns\n\nA function of specified Genz test function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseGridsKit.get_grid_points-Tuple{Any}","page":"Reference","title":"SparseGridsKit.get_grid_points","text":"get_grid_points(sg)\n\nRetrieves the grid points from a sparse grid (sg).\n\nArguments\n\nsg: A sparse grid object.\n\nReturns\n\nA vector of vectors, where each inner vector represents a grid point.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseGridsKit.get_margin-Tuple{MISet}","page":"Reference","title":"SparseGridsKit.get_margin","text":"get_margin(mi_set)\n\nCalculates the margin of a multi-index set (mi_set), which is the set of multi-indices that can extend the current set.\n\nArguments\n\nmi_set: An instance of MISet.\n\nReturns\n\nAn MISet containing the margin set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseGridsKit.get_mi-Tuple{MISet}","page":"Reference","title":"SparseGridsKit.get_mi","text":"get_mi(mi_set)\n\nRetrieves the list of multi-indices from a given MISet.\n\nArguments\n\nmi_set: An instance of MISet.\n\nReturns\n\nA vector of multi-index vectors.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseGridsKit.get_mi_set-Tuple{Any}","page":"Reference","title":"SparseGridsKit.get_mi_set","text":"get_mi_set(sg)\n\nGenerates a downwards-closed set of multi-indices from a sparse grid (sg).\n\nArguments\n\nsg: A sparse grid object.\n\nReturns\n\nAn MISet containing the downwards-closed set of multi-indices.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseGridsKit.get_n_grid_points-Tuple{Any}","page":"Reference","title":"SparseGridsKit.get_n_grid_points","text":"get_n_grid_points(sg)\n\nReturns the number of grid points in the sparse grid (sg).\n\nArguments\n\nsg: A sparse grid object.\n\nReturns\n\nThe number of grid points in the sparse grid.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseGridsKit.get_n_mi-Tuple{MISet}","page":"Reference","title":"SparseGridsKit.get_n_mi","text":"get_n_mi(mi_set)\n\nReturns the number of multi-indices in a given MISet.\n\nArguments\n\nmi_set: An instance of MISet.\n\nReturns\n\nThe number of multi-indices in the set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseGridsKit.get_reduced_margin-Tuple{MISet}","page":"Reference","title":"SparseGridsKit.get_reduced_margin","text":"get_reduced_margin(mi_set)\n\nCalculates the reduced margin of a multi-index set (mi_set), which removes indices already in the set.\n\nArguments\n\nmi_set: An instance of MISet.\n\nReturns\n\nAn MISet containing the reduced margin set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseGridsKit.integrate_L2_on_sparsegrid-Tuple{Any, Any, Any}","page":"Reference","title":"SparseGridsKit.integrate_L2_on_sparsegrid","text":"integrate_L2_on_sparsegrid(sg, f_on_grid, precomputed_lagrange_integrals; product=dot, precomputed_pairwise_norms=nothing)\n\nComputes the L2 norm of a function (f_on_grid) over a sparse grid (sg) using precomputed integrals.\n\nArguments\n\nsg: The sparse grid.\nf_on_grid: A vector of function values on the sparse grid.\nprecomputed_lagrange_integrals: Precomputed Lagrange integrals.\nproduct: A function to compute the inner product (default is dot).\nprecomputed_pairwise_norms: Optional precomputed norms for optimization.\n\nReturns\n\nThe L2 norm of the function over the sparse grid.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseGridsKit.integrate_on_sparsegrid-Tuple{Any, Any, Any}","page":"Reference","title":"SparseGridsKit.integrate_on_sparsegrid","text":"integrate_on_sparsegrid(sg, f_on_grid, precomputed_lagrange_integrals)\n\nIntegrates a function (f_on_grid) over a sparse grid (sg) using precomputed Lagrange integrals.\n\nArguments\n\nsg: The sparse grid for integration.\nf_on_grid: A vector of function values on the sparse grid.\nprecomputed_lagrange_integrals: A vector of precomputed Lagrange integrals.\n\nReturns\n\nThe integral of the function over the sparse grid.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseGridsKit.interpolate_on_sparsegrid-Tuple{Any, Any, Any}","page":"Reference","title":"SparseGridsKit.interpolate_on_sparsegrid","text":"interpolate_on_sparsegrid(sg, f_on_grid, target_points)\n\nInterpolates a function (f_on_grid) defined on a sparse grid (sg) to a set of target points.\n\nArguments\n\nsg: The source sparse grid.\nf_on_grid: A vector of function values on the sparse grid.\ntarget_points: A vector of target points for interpolation.\n\nReturns\n\nA vector of interpolated values at the target points.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseGridsKit.map_from_to-Tuple{Any, Any}","page":"Reference","title":"SparseGridsKit.map_from_to","text":"map_from_to(sg_from, sg_to)\n\nMaps data from one sparse grid (sg_from) to another (sg_to).\n\nArguments\n\nsg_from: The source sparse grid.\nsg_to: The target sparse grid.\n\nReturns\n\nA vector that maps data from sg_from to sg_to.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseGridsKit.precompute_lagrange_integrals-Tuple{Any}","page":"Reference","title":"SparseGridsKit.precompute_lagrange_integrals","text":"precompute_lagrange_integrals(max_mi)\n\nPrecomputes the product integrals for Lagrange basis functions up to a given maximum multi-index (max_mi).\n\nArguments\n\nmax_mi: The maximum multi-index for which to precompute integrals.\n\nReturns\n\nA vector of precomputed product integrals for the Lagrange basis.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseGridsKit.precompute_pairwise_norms-Tuple{Any, Any}","page":"Reference","title":"SparseGridsKit.precompute_pairwise_norms","text":"precompute_pairwise_norms(f_on_grid, product)\n\nPrecomputes pairwise norms for function values (f_on_grid) using a specified product function.\n\nArguments\n\nf_on_grid: A vector of function values on the sparse grid.\nproduct: A function to compute the product between pairs of function values.\n\nReturns\n\nA matrix of pairwise norms.\n\n\n\n\n\n","category":"method"},{"location":"#SparseGridsKit","page":"SparseGridsKit","title":"SparseGridsKit","text":"","category":"section"},{"location":"sparsegridintegration/#Sparse-Grid-Integration","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"","category":"section"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"Sparse grid interpolation in SparseGridsKit.jl relies on precomputed integrals of the Lagrange interpolation polynomials.","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"Integrals are currently computed solely assuming Clenshaw–Curtis points and a density function rho=frac12^n where n is the dimension of the parameter space Gamma=-11^n","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"To do this a maximum level number is selected.","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"    using SparseGridsKit, LinearAlgebra\n    pcl = precompute_lagrange_integrals(7)\n    pcl[2,1,:,:]","category":"page"},{"location":"sparsegridintegration/#Sparse-Grid-Integration-2","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"","category":"section"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"This is then used to integrate a sparse grid polynomial approximation. Consider the function f-11toR","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"    f(x) = @. 3.0*x^2 + 2.0*x + 1.0","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"The two-dimension function f(x_1) f(x_2)^2 mapping -11^2 to R^2 can be approximated using a constant function. The integral is expected (albeit a poor approximation to the true value).","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"    n,k = 2,0\n    mi_set = create_smolyak_miset(n,k)\n    sg = create_sparsegrid(mi_set)\n    f_on_grid = [[f(x[1]), f(x[2])^2] for x in get_grid_points(sg)]\n    # Test integrate_on_sparsegrid\n    integral_result = integrate_on_sparsegrid(sg, f_on_grid, pcl)\n    integral_result ≈ [1.0,1.0]","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"The integral estimate is improved by using a sparse grid with more grid points. The integral can be evaluated explicitly, and it is seen that the quadrature gets the correct result.","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"    n,k = 2,4\n    mi_set = create_smolyak_miset(n,k)\n    sg = create_sparsegrid(mi_set)\n    f_on_grid = [[f(x[1]), f(x[2])^2] for x in get_grid_points(sg)]\n    # Test integrate_on_sparsegrid\n    integral_result = integrate_on_sparsegrid(sg, f_on_grid, pcl)\n\n    integral_result ≈ [2.0,92/15]","category":"page"},{"location":"sparsegridintegration/#Sparse-Grid-L2(Gamma)-Norms","page":"Sparse Grid Integration","title":"Sparse Grid L^2(Gamma) Norms","text":"","category":"section"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"Often the weighted L^2(Gamma) norm is required. Squaring a polynomial approximation results in many higher degree polynomial terms –- it is not as simple as squaring the evaluations at each sparse grid point.","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"The precomputed L_rho^2(Gamma) integrals in pcl are used with the sparse grid approximation structure to exactly compute the L_rho^2(Gamma) norm of a sparse grid polynomial function. This requires the pairwise norms of the point evaluations to be computed using precompute_pairwise_norms. If the evaluations are vectors, a mass matrix can be supplied in (x,y)->dot(x,Q,y). ","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"For the function x the weighted L_rho^2(-11) norm is $ \\Vert x^2 \\Vert{L{\\rho}^2([-1,1])} = \\sqrt{3}'.","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"    n,k = 1,1\n    mi_set = create_smolyak_miset(n,k)\n    sg = create_sparsegrid(mi_set)\n    f_on_grid = [[x[1]] for x in get_grid_points(sg)]\n    pairwise_norms = precompute_pairwise_norms(f_on_grid, (x,y)->dot(x,y))\n    l2_integral_result = integrate_L2_on_sparsegrid(sg, f_on_grid, pcl)\n    l2_integral_result[1] ≈ sqrt(1/3)","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"Similarly, for x^2 we get Vert x^2 Vert_L_rho^2(-11)=sqrt5. ","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"    n,k = 1,3\n    mi_set = create_smolyak_miset(n,k)\n    sg = create_sparsegrid(mi_set)\n    f_on_grid = [[x[1]^2] for x in get_grid_points(sg)]\n    l2_integral_result = integrate_L2_on_sparsegrid(sg, f_on_grid, pcl)\n    l2_integral_result[1] ≈ sqrt(1/5)","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"Finally we consider the L^2_rho(-11^2) norm of f(x_1). This can be explicitly computed to be sqrt(9215).","category":"page"},{"location":"sparsegridintegration/","page":"Sparse Grid Integration","title":"Sparse Grid Integration","text":"    # Test precompute_pairwise_norms\n    n,k = 2,4\n    mi_set = create_smolyak_miset(n,k)\n    sg = create_sparsegrid(mi_set)\n    f_on_grid = [[f(x[1])] for x in get_grid_points(sg)]\n    pairwise_norms = precompute_pairwise_norms(f_on_grid, (x,y)->x.*y)\n    l2_integral_result = integrate_L2_on_sparsegrid(sg, f_on_grid, pcl)\n    l2_integral_result ≈ sqrt(92/15)","category":"page"}]
}
